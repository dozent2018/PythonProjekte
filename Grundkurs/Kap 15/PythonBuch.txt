Jochen ReinholdtPython GrundlagenErste Schritte zur Programmierung im Selbststudium

1	VORBEREITUNGEN	91.1	Installation unter Windows	91.2	Mac OSX	131.3	Visual Studio Code im Überblick	171.4	Code- Beispiele	181.5	Start der REPL Ohne Visual Studio Code	191.6	Programmdateien mit Visual Studio Code erzeugen und ausführen	201.7	Zusammenfassung	222	DATEN UND DATENTYPEN	232.1	Lernziele	232.2	Literale und Datentypen	232.3	Operatoren: Rechnen mit Zahlen	232.4	Zahlen-Vergleiche und Wahrheitswerte	252.5	Zeichenketten (Strings)	262.6	Weitere Datentypen	272.7	Zusammenfassung	273	VARIABLEN	293.1	Lernziele	293.2	Namen für Variablen	293.3	Erzeugung und Verwendung von Variablen	303.4	Abkürzungen bei Rechenoperationen	313.5	Mehrfachzuweisungen	313.6	Dynamische Datentypen	323.7	Objekte und Variablenzuweisungen	333.8	Zusammenfassung	354	KOMMENTARE	364.1	Verschiedene Möglichkeiten für Kommentare	364.2	Wieviel Kommentar ist angemessen?	365	FUNKTIONEN BENUTZEN	375.1	Lernziele	375.2	Was ist eine Funktion?	375.3	Die Funktionen print() und input()	385.4	Typen anzeigen und umwandeln	385.5	Weitere nützliche eingebaute Funktionen	395.6	Funktionen als Funktionsparameter	415.7	Zusammenfassung	425.8	Aufgaben	426	PROGRAMME MIT VERZWEIGUNGEN	446.1	Lernziele	446.2	Ein Python Programm entwerfen, erzeugen und testen	446.3	Entwurf	446.4	Die Programmierung von gerade.py	466.5	Den Programmfluss mit if steuern	466.6	if mit else erweitern	476.7	Verknüpfung mehrerer Bedingungen	526.8	Zusammenfassung	546.9	Aufgaben	557	PROGRAMME MIT WIEDERHOLUNGEN	577.1	Lernziele	577.2	Schleifen mit while	577.3	Break, continue und else	587.4	Zusammenfassung	607.5	Aufgaben	608	DIE STANDARDBIBLIOTHEK	648.1	Lernziele	648.2	Funktionen aus Modulen benutzen	648.3	Module, Funktionen und das import-System	658.4	Weitere Beispiele aus der Standardbibliothek	678.5	Zusammenfassung	688.6	Aufgaben	699	LISTEN	709.1	Lernziele	709.2	Eigenschaften von Listen	709.3	Listen erzeugen	709.4	Anzahl Elemente einer Liste	719.5	Listenelemente und ihr Index	729.6	Listen-Objekte kopieren	749.7	Teile von Listen verwenden	779.8	Zusammenfassung	789.9	Aufgaben	7910	DIE FOR-SCHLEIFE UND SEQUENZEN	8110.1	Lernziele	8110.2	Einfache Verwendung von range()	8110.3	Die for-Schleife	8110.4	Verwendung von start, stop und step	8210.5	Die for-Schleife mit Aufzählungen anderer Datentypen	8410.6	for und Listen	8410.7	for und Strings	8510.8	Iterable Objekte und Datentypen	8610.9	Erweiterung von for break, continue und else	8610.10	Zusammenfassung	8610.11	Aufgaben	8811	MEHR ZU STRINGS	9111.1	Lernziele	9111.2	String-Literale und -Variablen	9111.3	Ein String als Aufzählung von Zeichen	9111.4	Strings sind unveränderlich	9211.5	Strings formatieren	9311.6	Typ-Umwandlungen	9711.7	String-Inhalte untersuchen	9811.8	Zusammenfassung	9911.9	Aufgaben	9912	AUSNAHMEN BEHANDELN	10112.1	Lernziele	10112.2	Die Eingabe von Zahlen verbessern	10112.3	Andere Exceptions	10312.4	Verschiedene Exceptions in einer try-Suite	10312.5	Finally	10512.6	Zusammenfassung	10512.7	Aufgaben	10513	EIGENE FUNKTIONEN	10613.1	Lernziele	10613.2	Warum eigene Funktionen schreiben?	10613.3	Eine eigene Funktion schreiben	10613.4	Platzierung von Funktionsdefinitionen	10913.5	Parameter und Datentypen	11113.6	Rückgabewerte und Datentypen	11213.7	Anzahl Argumente und Rückgabewerte	11313.8	Funktionsannotationen	11413.9	Lokale und globale Variablen	11413.10	Variablen als Funktionsargumente	11713.11	Seiteneffekte und Programmierstil.	11913.12	Zusammenfassung	12013.13	Aufgaben	12114	WEITERE DATENSTRUKTUREN	12214.1	Lernziele	12214.2	Tupel	12214.3	Sets	12414.4	Dictionaries	12714.5	Iteration über Dictionaries	12814.6	Methoden, Operationen und Funktionen für Dictionaries	12914.7	Verschachtelte Dictionaries	13014.8	Listen, Tupel und Dictionaries kombinieren	13214.9	Flache und tiefe Kopien	13414.10	Zusammenfassung	13614.11	Aufgaben	13715	DATEIEN VERARBEITEN	13915.1	Lernziele	13915.2	Dateien mit with und open() lesen	13915.3	Dateien mit with und open() schreiben	13915.4	Ausnahmen bei open()	14115.5	CSV-Dateien	14115.6	Datenstrukturen haltbar machen	14515.7	Hintergrunde zu with	14515.8	Zusammenfasung	14515.9	Aufgaben	14516	MEHR ZU FUNKTIONEN UND MODULEN	14716.1	Der Docstring	147KLASSEN UND OBJEKTE	148MEHR ZU KLASSEN	149

1 VorbereitungenFür die Teilnahme an diesem Kurs benötigen Sie einen Computer, auf dem Sie selbst Software installieren können oder auf dem jemand für Sie die folgende Software installiert hat:• Python 3 (Zum aktuellen Zeitpunkt ist dies die Version 3.7.3, eventuell ist aber auch schon eine neuere Version verfügbar). Sie finden den aktuellen Download unter der folgenden URL:https://www.python.org/downloads/• Die kostenlose Entwicklungsumgebung Microsoft Visual Studio Code ( Zum aktuellen Zeitpunkt ist dies die Version 1.32.3, eventuell ist aber auch schon eine neuere Version verfügbar). Sie finden den aktuellen Download hier:https://code.visualstudio.com/DownloadAnmerkung:Sie können natürlich auch einen anderen Editor als Visual Studio Code benutzen. Sie finden in diesem Buch aber keine Hinweise zur Installation oder Benutzung anderer Produkte.Die Installation von Python unter Windows unterscheidet sich von der Installation unter Mac OSX. Sie finden die nötigen Hinweise jeweils in einem separaten Kapitel. Eventuell ist Python aber schon auf Ihrem Rechner installiert. 1.1 Installation unter WindowsSchritt 1 – Prüfen Sie, ob Python bereits installiert ist:• Öffnen Sie das Startmenü mit einem Klick auf das Windows-Symbol.• Tippen Sie «cmd» oder «Eingabeaufforderung» in das Suchfeld ein.• Klicken Sie auf den Eintrag «Eingabeaufforderung». • Sie sehen ein Terminalfenster, in dem Sie Kommandos eingeben könnenIn diesem Fenster geben Sie «python --version» ein. Wenn folgende Ausgabe erscheint, ist Python 3 bereits auf Ihrem Computer installiert.C:\Users\Ich>python --versionPython 3.7.3Wenn die angezeigte Version 3.6 oder höher ist, brauchen Sie nichts weiter zu tun und können mit der Installation von Visual Studio Code fortfahren.Wenn Python noch nicht installiert ist, sehen Sie eine andere Meldung:C:\Users\Ich>python --versionDer Befehl "python" ist entweder falsch geschrieben oderkonnte nicht gefunden werden.Schritt 2 - Download und Installation von Python 3Gehen sie auf die Seite https://www.python.org/downloads/  und laden Sie die Datei python-3.7.3-amd64.exe (Für die meisten modernen Computer mit 64-bit CPU empfehlenswert) oder python-3.7.2.exe (Für ältere Computer mit 32-Bit CPU) herunter. Wenn Sie einen höhere Version finden, laden Sie stattdessen diese herunter.Starten Sie das Installationsprogramm mit einem Doppelklick. Folgendes Fenster erscheint: Wichtig: Wählen Sie hier zusätzlich «Add Python 3.7 to PATH» aus und klicken Sie erst dann auf «Install Now»Wenn Diese Abfrage erscheint, klicken Sie auf «Ja» und erlauben Sie, dass das Installationsprogramm Änderungen an Ihrem Computer durchführtNach einer erfolgreichen Installation erscheint dieses Fenster:Schritt 3 - Installation von Visual Studio Code unter WindowsGehen Sie auf die Seite https://code.visualstudio.com/DownloadLaden Sie die Installer-Datei VSCodeUserSetup-x64-1.32.3 oder eine höhere Version herunter und führen Sie diese aus. Sie können Sie den Empfohlenen Voreinstellungen folgen:Beim Schritt «Zusätzliche Aufgaben auswählen» können Sie optional ein Desktop-Symbol für Code anlegen und das Öffnen von Code-Dateien im Explorer ermöglichenWenn Die Installation beendet ist, startet Visual Studio CodeSchritt 4 - Konfiguration von Visual Studio Code (Windows)Rufen Sie Visual Studio Code auf, wenn es nach der Installation nicht automatisch gestartet wurde.In der unteren linken Ecke des Hauptfensters von Visual Studio Code  finden Sie ein Tool-Symbol (Zahnrad). Klicken Sie darauf und wählen Sie den Menueintrag «Extensions»Im Suchfeld unter «Extensions» können Sie Python eingeben. Sie sehen eine Reihe von Erweiterungen für Python, die sie auswählen können.Finden und installieren Sie die «Python Extension For Visual Studio Code» von Microsoft Corporation.Anpassen des Erscheinungsbildes:Klicken Sie auf das Tool-Symbol im Hauptfenster unten Links uns wählen Sie «Color Theme»Sie können zwischen verschiedenen «Themen» auswählen – probieren Sie diese einfach aus und wählen Sie eines, das Ihnen gefällt!1.2 Mac OSXSchritt 1 – Prüfen, ob Python 3 bereits installiert istUnter OSX ist Python bereits vorinstalliert, aber leider in der älteren Version 2.7, die sich zu stark von der Version 3.6, die in diesem Kurs mindestens gebraucht wird unterscheidet. Die Abfrage der Version erfolgt ähnlich wie unter Windows in einem Terminalfenster, öffnen Sie bitte ein Terminalfenster mit dem Programm «Terminal». Dieses finden Sie im Finder im Ordner Programme.Das Zeichen $ am Anfang der Zeilen ist die Eingabeaufforderung, bitte bei der Eingabe der Kommandos nicht mitschreiben$ python --versionPython 2.7.10Eventuell ist Python 3 ebenfalls installiert. Prüfen Sie das mit:$ python3 –versionPython 3.7.3Man sollte das vorhandene Python 2.7.10 nicht einfach durch Python 3 ersetzen, denn 2.7.10 wird eventuell noch von verschiedenen Systemtools gebraucht. Sie müssen also Python 3 zusätzlich installieren. Schritt 2 – Download und Installation von Python 3 unter Mac OSX (Standard)In diesem Kapitel wird die Standardinstallation beschrieben – Das ist die für die meisten Mac OSX – Benutzer der empfohlene Weg. Anmerkung für homebrew-Benutzer: Falls Sie es bevorzugen sollten, Software-Pakete auf Ihrem Mac mit dem freien Paketmanager homebrew zu installieren, lesen Sie stattdessen das nächste Kapitel.Der Download-Link für Mac OSX ist https://www.python.org/downloads/mac-osx/Wenn Sie eine aktuelle  Mac OSX Version ab 10.9 («Mavericks») installiert haben, ist das korrekte Installationspaket der macOS 64-bit installer python-3.7.3-macosx10.9.pkgFalls Sie noch eine ältere Version (10.6 bis 10.8)  von Mac OSX benutzen, brauchen Sie das Paket  macOS 64-bit/32-bit installer python-3.7.3-macosx10.6.pkgStarten Sie die Installation durch Doppelklick und folgen Sie den AnweisungenNach erfolgreicher Installation erscheint diese MeldungAnschliessend sollten Sie ein neues Terminal-Fenster öffnen und den Erfolg überprüfen:$ python3 –versionPython 3.7.3Unter Mac OSX gibt nun zwei verschiedene Aufrufe von Python im Terminal:• Das Kommando python ruft die alte Version 2.7.x auf. Das Tool zum installieren zusätzlicher pakete heisst pip• Das Kommando python3 ruft die neue Version 3.7.x auf, die in diesem Kurs verwendet wird. Wenn Sie Pakete nachladen wollen, benutzen Sie  pip3 Leser mit einem Mac müssen also die Kommandos python3 bzw. pip3 benutzen Schritt 2a - Alternative Installation für homebrew-Benutzer unter Mac OSXDieser Abschnitt betrifft nur Anwender, die lieber den Paketmanager homebrew benutzen. Falls das für Sie nicht zutrifft, überspringen Sie Ihn einfach und fahren Sie beim Abschnitt «Installation von Visual Studio Code unter Mac OSX» fort.Die Installation mit homebrew benötigt als Voraussetzung Apples Entwicklungsumgebung Xcode und die Xcode Kommandozeilentools. Prüfen Sie in einem Terminalfenster , ob diese vorhanden sind:$ xcode-select -p/Library/Developer/CommandLineToolsFalls nicht, müssen Sie zunächst Xcode installieren. Laden Sie es über den Apple OSX AppStore. Wenn Sie es  installiert haben, geben Sie in einem Terminal-Fenster folgendes ein, um die Kommandozeilentools zu installieren:$ xcode-select --installDa es sich um ein sehr grosses Paket handelt, kann das einige Zeit dauern. Anschliessend installieren Sie den (sehr empfehlenswerten) Paketmanager Homebrew, falls Sie diesen nicht bereits installiert haben:$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"(Das  Kommando wurde hier aus Platzgründen auf zwei Zeilen umgebrochen - Geben Sie das bitte auf Einer Zeile ein, mit einem Leerzeichen vor https: )Prüfen Sie dann, ob Homebrew funktioniert:$ brew doctorYour system is ready to brew.Anschliessend installieren Sie Python 3:$ brew install python3. . .. . . Viele Text-Ausgaben . . .. . .==> pythonPython has been installed as  /usr/local/bin/python3. . .Das kann je nach Netzwerkverbindung einige Minuten dauern und sehr viele Ausgaben erzeugen, da eventuell noch diverse andere Pakete installiert werden, von denen python3 abhängig ist. Prüfen Sie den Erfolg mit:$ python3 –versionPython 3.7.3Python 2.7 ist jetzt weiterhin vorhanden:$ python –versionPython 2.7.10Schritt 3 - Installation Von Visual Studio Code unter Mac OSXGehen Sie im Browser zu https://code.visualstudio.comDort finden Sie den Download der neuesten Version von Code:Verschieben Sie die heruntergeladene App von «Downloads» in «Programme» und öffnen Sie sie anschliessend mit einem Doppelklick. Der folgende Dialog erscheint:Klicken Sie auf «Öffnen»Konfiguration von Visual Studio CodeSie können nun den Instruktionen für Windows am Ende von Kapitel 1.1 folgen, die Konfiguration unter Mac OSX unterscheidet sich nicht von der unter Windows
1.3 Visual Studio Code im ÜberblickStarten Sie das frisch installierte Programm Visual Studio Code und sehen Sie sich die verschiedenen Bereiche des Hauptfensters an:Abbildung 11 Bereiche im Hauptfenster von Visual Studio CodeWichtige Bereiche in diesem Fenster sind:1. Eine Leiste mit Symbolen. Die ersten zwei Symbole sind: «Öffnen des Explorer für Dateien» und «Suchen und ersetzen» in Dateien2. Der Explorer. Er zeigt Workspaces mit Unterverzeichnissen und den dort von Ihnen angelegten Python-Programmen an3. Das Editor-Fenster, in dem Sie Programmcode bearbeiten können4. Das Terminal-Fenster, in dem Sie Ihre Programme ausführenWeitere Bereiche und Symbole sind:Abbildung 12 Weitere Bereiche und Symbole5. Das Tool-Symbol (Zahnrad). Über dieses Symbol können Sie Kommandos ausführen und diverse Einstellungen in Visual Studio Code vornehmen.6. Über dem Terminal-Fenster befindet sich ein Auswahl-Feld. Hier können Sie auswählen, ob im Bereich darunter das Terminal oder die REPL angezeigt wird7. In der REPL-Ansicht können in diesem Bereich einzelne Python-Ausdrücke eingegeben werden1.4 Code- BeispieleIn diesem Buch finden sie viele Code-Beispiele, die Sie ausprobieren sollten. Sie werden in einer anderen Schrift und eingerückt dargestellt. In diesem Buch finden Sie zwei verschiedenen Formen von Beispielen.Beispiele der Form 1 beziehen sich auf Eingaben am interaktiven Prompt >>> Ein Beispiel dafür ist:>>> 'Hallo Python''Hallo Python'>>>Diese Form der Eingabe wird «Read–Eval–Print Loop» oder REPL genannt. Die Abkürzung steht für:• READ: Ihre Eingabe am >>> Prompt wird gelesen• EVAL: Der Python Interpreter wertet ihre Eingabe aus• PRINT: Der Python Interpreter gibt das Ergebnis der Auswertung aus• LOOP: Das Ganze geht wieder von vorne los, Sie sehen wieder den >>> Prompt und können die nächste Eingabe machen oder mit der Tastenkombination Control-D (Strg-D) die REPL verlassenWie sie die REPL benutzen, erfahren Sie in den Abschnitten 0 und 1.5Beispiele der Form 2 hat durchgehend nummerierte Zeilen:  1  text1 = 'Hallo' 2  text2 = 'Python' 3 4  print(text1, text2)Alle nummerierten Code-Beispiele erfassen Sie im Editor als Text-Datei mit der Endung .py ( in diesem Beispiel hallo.py ) und führen sie anschliessend aus. Die Form 3 hat weder den >>> Prompt noch nummerierte Zeilen, sondern ein $ - Zeichen in der 1. Zeile. Das sind Kommandos, die Sie in einem Terminal-Fenster Ihres Computers eingeben, z.B. zur Ausführung des gespeicherten Programms hallo.py. Das $ - Zeichen steht für die Eingabeaufforderung im Terminal, sie schreiben es also nicht mit:$ python hallo.pyHallo Python$Wie sie Python-Programme erzeugen und ausführen, erfahren Sie ab Kapitel 4Start der REPL in Visual Studio Code:Suchen Sie das Zahnrad-Symbol in der unteren linken Ecke von Microsoft Visual Studio Code und klicken Sie es an:Wählen Sie «Command Palette»In der Liste der verfügbaren Kommandos suchen Sie nach «Python: Starten des REPL» und wählen dieses Kommando aus.Im unteren Bereich des Hauptfensters erscheint ein neues Fenster mit einigen Informationen zur installierten Python-Version und schliesslich der >>> Prompt, an dem Sie Ihre Eingaben machen können:Sie können die REPL offen lassen, um die Beispiele im nächsten Kapitel auszuprobieren oder sie mit Control-D (Strg-D) beenden1.5 Start der REPL Ohne Visual Studio CodeFalls Sie Visual Studio Code nicht benutzen wollen oder können, können Sie auch in einem Terminalfenster python oder python3 eingeben. Dann erscheint ebenfalls der Prompt >>>>>> Eingabe einer Python-CodezeileAusgabe von Python>>> Eingabe einer weiteren Python-CodezeileNächste Ausgabe von Python1.6 Programmdateien mit Visual Studio Code erzeugen und ausführenIn der oberen linken Ecke des Hauptfensters von Visual Studio Code sehen Sie den «Explorer» Bereich, der in etwa so aussehen sollte:Wählen Sie Im Menu File -> Open …Erzeugen Sie zunächst einen neuen Ordner, in dem Sie Ihre Programme speichern können:Wählen Sie «Neuer Ordner». Wählen Sie einen Namen für den neuen Ordner und klicken Sie auf «Erstellen». Wählen Sie «Öffnen» Dann erscheint ein sogenannter Workspace mit dem Namen «PYTHONPROGRAMME» im Explorer-Bereich. Wenn Sie den Mauszeiger darauf bewegen, sehen Sie mehrere Icons. Ein Klick auf das erste Icon öffnet eine neue DateiEin Eingabefeld öffnet sich. Geben Sie darin den Namen «hello.py» einNun ist ein Editorfenster mit dem Namen hello.py geöffnet. Geben Sie dort die Zeile, die sie im Bild sehen ein:Dieses Mini-Programm können Sie nun ausführen. Nach einem Rechtsklick auf hello.py im Explorer-Bereich (Mac: Control-Klick)  erscheint ein Menu, bei dem Sie den Eintrag «Python Datei im Terminal ausführen» wählen.Im unteren Bereich des Hauptfensters erscheint dann die Terminal-Ausgabe des Programms:1.7 ZusammenfassungWenn Sie Die Schritte in diesem Kapitel erfolgreich durchgeführt haben steht Ihnen nun folgende Werkzeuge zur Verfügung:• Der Python-Interpreter in der Version 3.7.3 oder höher. Diese Software führt ihren Programmcode aus.• Die Entwicklungsumgebung Visual Studio Code, die eine Reihe von komfortablen Werkzeugen für das Erstellen und das Testen Ihrer Programme bietet.Sie sind damit für das Nachvollziehen der Beispiele und Übungen in diesem Buch vorbereitet.2 Daten und DatentypenBevor Sie mit dem Programmieren beginnen, müssen Sie sich mit einigen wichtigen Grundelementen der Programmiersprache Python vertraut machen. Dies sind zunächst einmal verschiedene Arten von Daten und Operationen, die man mit den Daten ausführen kann.Dies erfolgt am besten interaktiv, weil das Erlernen neuen Wissens durch das Ausprobieren von Beispielen und eigene Experimente sehr viel effektiver ist als das blosse Lesen. Python unterstützt dieses Experimentieren durch die Möglichkeit, Daten und Anweisungen direkt einzugeben und das Resultat sofort anzuzeigen. Bitte nutzen Sie diese Möglichkeit intensiv. Probieren Sie alle Beispiele in diesem Kapitel aus und machen Sie eigene Experimente!2.1 LernzieleNach der Bearbeitung dieses Kapitels können Sie:• Den Begriff Literal erklären • Vier einfache Datentypen in Python benennen • In Python Berechnungen mit Zahlen und verschiedenen Grundrechenarten ausführen• Texte erzeugen und miteinander verknüpfen• Logische Vergleiche mit Zahlen und Texten anstellen2.2 Literale und DatentypenLiterale sind Datenwerte, die direkt von Ihnen eingegeben werden. Python unterstützt Literale, die zu verschiedenen Datentypen gehören können. Die vier einfachen Datentypen von Python, die Sie in diesem Abschnitt kennenlernen werden, sind:• Ganze Zahlen (Datentyp int)• Fliesskommazahlen (Datentyp float)• Zeichenketten (Datentyp str)• Wahrheitswerte (Datentyp bool)Auf Daten dieser verschiedenen Datentypen können sie verschiedene Operationen anwenden, z.B. die Grundrechenarten auf Daten der Typen int und float2.3 Operatoren: Rechnen mit ZahlenFür das Nachvollziehen der Beispiele starten Sie bitte die REPL von Python (Falls Sie die Beschreibung dazu brauchen, schlagen Sie in Kapitel 1.4 nach)Sie sollten nun den Prompt >>> sehen. Das ist die Eingabeaufforderung von Python.Wenn Sie am >>> Prompt eine Zahl eingeben, gibt Ihnen Python einfach den eingegebenen Wert zurück:>>> 199199Die GrundrechenartenDie Zeichen für die Grundrechenarten Addition ( + ), Subtraktion ( - ), Multiplikation ( * )  und Division ( / ) in Python entsprechen denen im Alltagsgebrauch. Sie werden in einer Programmiersprache Operatoren genannt. Geben Sie einige einfache Berechnungen ein und Python liefert Ihnen sofort das Ergebnis zurück:>>> 199 + 1200>>> 7 - 43>>> 3 * 39Diese Literale (Die Werte, die Sie eingeben) und die Ergebnisse der Berechnungen sind vom Datentyp int (Ganze Zahl)>>> 9 / 24.5>>> 33.33333 * 1003333.3329999999996Das Ergebnis der Divisionen ist vom Datentyp float (Fliesskommazahl), ebenso wie Ihre Eingabe 33.33333. In Python wird für Eingaben und Ausgaben von float-Werten ein Dezimalpunkt statt eines Dezimalkommas verwendet. Das Komma hat in Python eine spezielle Bedeutung. Zwei Zahlen mit einem Komma dazwischen werden als Aufzählung behandelt. Vergleichen Sie die Ergebnisse der folgenden Eingaben:>>> 2,5(2, 5)>>> 2.52.5>>> 2.5 + 13.5>>>>>> 2,5 + 1(2, 6)Berechnungen, die eine Fliesskommazahl ergeben, haben nicht immer bis auf die letzte Kommastelle exakte Ergebnisse, da die Hardware eines Computers nur mit einer begrenzten Genauigkeit rechnen. Python zeigt immer gerundete Werte an, es kann daher bei Berechnungen mit vielen Nachkommastellen zu Rundungsfehlern kommen.Weitere OperatorenDie ganzzahlige Division ( // ) ist eventuell weniger bekannt, sie liefert immer eine ganze Zahl zurück. Der Divisionsrest wird mit dem Modulo-Operator ( % ) ermittelt:>>> 9 // 24>>> 9 % 21Die bekannten Regeln zur Punkt- und Strichrechnung und die Verwendung von Klammern gelten auch in Python:>>> 3 * 3 + 110>>> 3 * (3 + 1)12Potenzen wie 24 werden mit dem Operator ** geschrieben:>>> 2 ** 4162.4 Zahlen-Vergleiche und WahrheitswerteDie folgenden Vergleichs-Operatoren können für Zahlen verwendet werden:OperatorBedeutung==Gleichheit>Grösser als<Kleiner als>=Grösser oder gleich<=Kleiner oder gleich!=UngleichWendet man diese Operatoren an, ist das Ergebnis immer entweder True (Wahr) oder False (Nicht wahr). Diese beiden speziellen Werte sind vom Datentyp bool (Wahrheitswert).>>> 2 == 2True>>> 2 < 3True>>> 2 > 3False>>> 23.66 < 22.661False>>> 23.66 <= 22.66False>>> 23.66 <= 23.66TrueMit dem Schlüsselwort not wird ein Wahrheitswert in sein Gegenteil umgekehrt (Negation):>>> not TrueFalse>>> not FalseTrue>>> not 2 == 2False>>> not 2 < 2True2.5 Zeichenketten (Strings)Zeichenketten sind vom Datentyp str. Werden sie als Literale geschrieben, müssen Sie mit Anführungszeichen umgeben werden. Dabei können einfache wie auch doppelte Anführungszeichen verwendet werden, aber die führenden und schliessenden Anführungszeichen müssen von der gleichen Art sein:>>> "Dies ist eine Zeichenkette"'Dies ist eine Zeichenkette'>>> "Dies ist ein Text'  File "<stdin>", line 1    "Dies ist ein Text'SyntaxError: EOL while scanning string literalDer Python-Interpreter erwartet beim zweiten Beispiel ein doppeltes Anführungszeichen als Abschluss des Textes, findet aber nur ein Einfaches. Ein SyntaxError ist eine Verletzung der Regeln der Programmiersprache Python. Diese Art von Fehler wird erst festgestellt, wenn die Anweisung ausgeführt wird. Sie werden wahrscheinlich beim Üben mit Python noch häufig eine solche Meldung erhalten, weil Sie sich vertippt haben. Dann müssen Sie herausfinden, was Sie falsch gemacht haben und das Problem beheben.Zeichenketten können mit dem Operator + verkettet werden. Dabei werden Leerzeichen wie gewöhnliche Zeichen behandelt:>>> 'Dies ist eine Zeichenkette' + 'und' + 'dies auch''Dies ist eine Zeichenketteunddies auch'>>> 'Dies ist eine Zeichenkette' + ' und ' + 'dies auch''Dies ist eine Zeichenkette und dies auch'Soll in einer Zeichenkette ein einfaches oder doppeltes Anführungszeichen enthalten sein, muss es in der jeweils anderen Art von Anführungszeichen eingeschlossen werden, sonst gibt Ihnen Python eine Fehlermeldung zurück:>>> 'This doesn't make sense'  File "<stdin>", line 1    'This doesn't make sense'                SyntaxError: invalid syntax>>> "This doesn't make sense""This doesn't make sense">>> 'Ein "SyntaxError" zeigt eine Verletzung der Regeln von Python an''Ein "SyntaxError" zeigt eine Verletzung der Regeln von Python an'Eine Alternative ist das Voranstellen eines Backslash ( \ ) vor jedem Anführungszeichen innerhalb der Zeichenkette:>>> "Der \"Backslash\" hebt die Sonderbedeutung eines Zeiches auf"'Der "Backslash" hebt die Sonderbedeutung eines Zeiches auf'>>>Strings können ebenfalls mit logischen Operatoren verglichen werden, Beispiele dafür sind:>>> 'Bernd' > 'Beate'True>>> 'Bernd' == 'Beate'False>>> 'J' == 'j'False2.6 Weitere DatentypenPython hat noch einen weiteren einfachen Datentyp: complex wird für komplexe Zahlen verwendet, die aber in diesem Buch nicht behandelt werden. Darüber hinaus gibt es sogenannte Datenstrukturen wie Liste, Tupel, Set und Dictionary, die sie in den Kapitel 9 und 14 kennenlernen werden.2.7 Zusammenfassung• Literale sind Datenwerte, die in der REPL von Python oder in Programmen direkt eingeben werden.• Sie können verschiedene Datentypen haben. Beispiele für Datentypen sind: int (ganze Zahl), float(Fliesskommazahl) und str(Zeichenkette).• Fliesskomma-Literale werden mit einem Dezimalpunkt (statt Komma) geschrieben• String-Literale müssen mit einfachen oder doppelten Anführungszeichen geschrieben werden• Mit int- und float-Zahlen können Rechenoperationen ausgeführt werden. Die dabei angewendeten arithmetischen Operatoren sind: + ,  - ,  * ,  / ,  //  und  % , wobei die letzten beiden für die ganzzahlige Division und den Divisionsrest (Modulo) stehen.• Mehrere String-Literale können mit + vereinigt werden• Logische Vergleiche können sowohl mit Zahlen wie auch mit Strings durchgeführt werden. Dafür werden logischen Operatoren benutzt  ( == ,  != ,  > ,  >= ,  < ,  <= ) Das Ergebnis ist immer ein Wert vom Typ bool. Mögliche bool-Werte sind True für «wahr» und False für «nicht wahr».3 VariablenNachdem Sie im vorigen Kapitel die Darstellung von Daten als Literale kennengelernt haben, fragen Sie sich vielleicht, ob man Daten in Programmen immer direkt eingeben muss. Schliesslich kennen Sie aus dem Mathematikunterricht Formeln, in denen Zahlen durch Buchstaben dargestellt werden, wie etwa(a + b)2 = a2 + 2ab + b2Variablen sind ein wesentlicher Bestandteil einer höheren Programmiersprache. Sie erlauben es, Daten einen symbolischen Namen zu geben. 3.1 LernzieleNach der Bearbeitung dieses Kapitels können Sie:• Variablen geeignete Namen geben• Variablen erzeugen und Ihnen verschiedene Werte zuweisen• Operationen mit Variablen ausführen• Erklären, was Variablen und Objekte sind• Den Datentyp von Variablen ermitteln• Das dynamische Datentypkonzept von Python erklären3.2 Namen für VariablenEs gilt die Einschränkung, dass die Wörter, die zur Programmiersprache Python gehören (reservierte Wörter) nicht als Variablennamen verwendet werden können:False      await      else       import     passNone       break      except     in         raiseTrue       class      finally    is         returnand        continue   for        lambda     tryas         def        from       nonlocal   whileassert     del        global     not        withasync      elif       if         or         yield	Einige weitere Regeln und Empfehlungen zum Vergeben von Namen für Variablen sind:• Klein- und Grossschreibung wird strikt unterschieden: «Buchwert» und «buchwert» sind zwei verschiedene Namen und bezeichnen zwei verschiedene Variablen!• Namen dürfen nicht mit Zahlen beginnen• Sie sollten sprechende Namen verwenden, zum Beispiel «lohn» statt «l», «index» statt «i», auch wenn das etwas mehr Schreibaufwand bedeutet• Variablen-Namen sollten in Kleinbuchstaben geschrieben werden• In der Regel werden Teile von längeren Namen mit Unterstrichen separiert. Beispiel: «anzahl_eingaben» • Sie sollten keine Umlaute, andere Sonderzeichen oder Satzzeichen in Namen verwenden3.3 Erzeugung und Verwendung von VariablenVariablen können in Python an irgendeiner Stelle eines Programms erzeugt und danach verwendet werden. Die folgenden Beispiele zeigen dies für Zahlen und Zeichenketten:>>> meine_zahl = 42>>> meine_zahl42>>> type(meine_zahl)<class 'int'>Hier wurde type(variable) verwendet, um festzustellen, welchen Datentyp Python aus der Zuweisung meine_zahl = 42 abgeleitet hat (in diesem Fall «int»). Das gleiche Vorgehen kann man mit anderen Zuweisungen ausprobieren:>>> mein_name = 'Hans'>>> mein_name'Hans'>>> type(mein_name)<class 'str'>>>> mein_gewicht = 80>>> type(mein_gewicht)<class 'int'>>>> meine_groesse = 179.8>>> type(meine_groesse)<class 'float'>Variablen können anstelle von Literalen in Anweisungen verwendet werden. Der Python-Interpreter prüft dabei die Typen der Variablen und Literale und führt die Anweisung aus, wenn die Typen kompatibel sind. Im Folgenden werden zwei Zeichenketten verknüpft:>>> "Mein Name ist " + mein_name'Mein Name ist Hans'Die Folgende Berechnung verwendet eine Variable vom Typ int  (meine_groesse), eine float-Variable und ein Literal vom Typ int (2).>>> mein_bmi = meine_groesse / (mein_gewicht ** 2)>>> mein_bmi0.027745843138767795>>> type(mein_bmi)<class 'float'>Die Variable mein_bmi wird bei der Ausführung der Anweisung erzeugt und bekommt automatisch den kompatiblen Typ float.Werden Variablen mit nicht kompatiblen Typen in einer Anweisung benutzt, gibt es einen TypeError:>>> "Mein Gewicht ist " + mein_gewichtTraceback (most recent call last):  File "<stdin>", line 1, in <module>  TypeError: can only concatenate str (not "int") to str3.4 Abkürzungen bei RechenoperationenPython erlaubt einige Abkürzungen beim Schreiben von Rechenoperationen, bei denen der Wert einer einzelnen Variablen verändert wird. Die Erhöhung eines Zahlenwerts um 1 kommt in Programmen sehr häufig vor. Das können Sie so schreiben:>>> zahl = zahl + 1Oder so:>>> zahl += 1Diese Kurzschreibweise gint es auch für andere Rechenoperationen, beispielweise>>> zahl -= 1 # entspricht zahl = zahl - 1>>> zahl *= 2 # entspricht zahl = zahl * 2>>> zahl /= 2 # entspricht zahl = zahl / 2Abgesehen von der Schreibersparnis verhalten Sich diese Rechenoperationen exakt so, wie bei den voll ausgeschriebenen Varianten3.5 MehrfachzuweisungenIn Python ist es möglich, mehrere Zuweisungen zu einer Anweisung zusammenzufassen. In der ersten Anweisung wird den Variablen zahl1 und zahl2 gleichzeitig je ein Zahlenwert zugewiesen. Die erste Variable auf der linken Seite bekommt den ersten Wert auf der rechten Seite und die zweite Variable auf der rechten Seite den zweiten Wert auf der linken.>>> zahl1, zahl2 = 2, 4>>> zahl12>>> zahl24In der zweiten Anweisung werden die Variablen zahl1 und zahl2 sowohl auf der linken wie auf der rechten Seite des Gleichheitszeichens verwendet:>>> zahl1, zahl2 = zahl2, zahl1 + zahl2>>> zahl14>>> zahl26Die zweite Anweisung demonstriert, dass die Variablenwerte auf der rechten Seite noch die alten sind (zahl1 == 2 und zahl2 == 4) obwohl auf der linken Seite bereits an zahl1 der Wert von zahl2 ( 4 ) zugewiesen wurde. Die beiden Zuweisungen erfolgen also nicht nacheinander, sondern gleichzeitig.Sollen mehrere Variablen den gleichen Wert bekommen, ist auch folgende Art der Zuweisung möglich:>>> x = y = z = 0>>> x0>>> y0>>> z03.6 Dynamische DatentypenPython gehört zu den dynamischen Programmiersprachen. Das heisst, in einem Python-Programm kann sich der Datentyp einer Variablen im Verlauf eines Programms ändern! Beachten Sie das folgende Beispiel, bei dem der Variablen mit dem Namen «mein_gewicht» vom ursprünglichen Typ int eine Zeichenkette zugewiesen wird :>>> type(mein_gewicht)<class 'int'>>>> mein_gewicht80>>> mein_gewicht = "Etwas zu hoch">>> type(mein_gewicht)<class 'str'>>>> mein_gewicht'Etwas zu hoch'Der Typ von «mein_gewicht» (int)wurde nach der Zuweisung eines String-Wertes auf den Typ str geändert.Andere Programmiersprachen mit statischen Typen wie C oder Java erlauben dieses Verhalten nicht, dort wird der Typ einer Variablen einmal im Programm festgelegt und ändert sich danach nicht mehr. Wenn in diesen Sprachen einer Variablen ein Wert mit einem unpassenden Typ zugewiesen wird, gibt dies sofort eine Fehlermeldung. Für Verwendung von Werten mit dem korrekten Datentyp bei der Zuweisung an Variablen ist der Python-Programmierer selbst verantwortlich!3.7 Objekte und VariablenzuweisungenAlle Literale und Variablen sind in Python sogenannte Objekte. Objekte haben Eigenschaften, und Methoden. Die Eigenschaft einer Zahl ist ihr Wert, die Eigenschaft einer Zeichenkette ist der darin gespeicherte Text und Die Eigenschaft eines Wahrheitswertes ist der Wert True oder False. Der Name einer Variablen zeigt auf ein Objekt, dass einen bestimmten Wert hat und zu einer bestimmten Klasse gehört ( Sie haben sicher den Begriff «class» bei der Ausgabe von type() bemerkt – eine Klasse ist der Typ eines Objekts).Abbildung 31: Der Name der Variablen «zeigt» auf ein Objekt im Hauptspeicher des Computers.Die folgende Abbildung zeigt dies an zwei Beispielen aus den vorhergehenden Abschnitten:Abbildung 32 Zwei Variablen zeigen auf zwei Objekte unterschiedlichen TypsWie verhalten sich nun Variablen und die Objekte bei Zuweisungen? Machen Sie folgendes Experiment:>>> mein_name = 'Hans'>>> vorname = mein_name>>> vorname'Hans'>>> mein_name = mein_name + " Kurz">>> mein_name'Hans Kurz'>>> vorname'Hans'Man unterscheidet in Python Objekte, deren Wert verändert werden kann (mutable Objects) und solche, deren Wert nicht verändert werden kann (immutable Objects). Strings sind immer unveränderliche Objekte.In der ersten Zuweisung wird mit der Variable «vorname» nur ein weiterer Name erzeugt, der auf das String-Objekt1 zeigt. Bei der Zuweisung (2) wird dagegen ein neues String-Objekt2 erzeugt, auf das die Variable «mein_name» zeigt. Die Variable «vorname» zeigt weiterhin auf das String-Objekt1. Somit existieren nach (2) zwei unabhängige Objekte.Abbildung 33 Objektreferenzen nach einer Zuweisung und nach einer ÄnderungAuch die Objekte der anderen Datentypen, die Sie bisher kennengelernt haben sind immutable. Auch bei Zahlen vom typ int oder float wird bei einer Wertzuweisung ein neues Objekt erzeugt. Wenn Sie das überprüfen wollen, können Sie mit id(variablenname) die interne Objekt-Nummer des Objekts abfragen, auf die eine Variable verweist:>>> name = 'Hans'>>> id(name)4511693488>>> name = name + ' Kurz'>>> name'Hans Kurz'>>> id(name)4511690032>>> zahl = 1>>> id(zahl)4508728496>>> zahl = zahl + 1>>> zahl2>>> id(zahl)4508728528>>>Sie sehen, dass die Objekt-Nummer sich nach jeder Änderung des Inhalts verändert, obwohl der Variablenname gleichbleibt. Sie werden im Verlauf dieses Buchs noch andere Python-Datentypen kennenlernen, die im Gegensatz zu str, int oder float veränderlich (mutable) sind.
3.8 ZusammenfassungZu Variablen• Objekte enthalten die Daten eine Programms. • Auf diese Daten kann über Variablen zugegriffen werden. Variablen sind symbolische Namen für Objekte.• Variablen-Namen beginnen mit einem Buchstaben und es dürfen keine reservierten Wörter der Sprache verwenden werden. Umlaute und Sonderzeichen sollten vermieden werden. Ansonsten gibt es keine Einschränkung bei der Vergabe von Namen, es ist aber eine Konvention, Variablennamen klein zu schreiben und längere Namen mit Unterstrichen lesbarer zu machen, z.B. «anzahl_fahrzeuge».• Eine Variable wird durch eine erstmalige Zuweisung eines Wertes in der Form Variablenname = Wert  oder Variablenname = Variablenname erzeugt. Der Datentyp des Werts oder der Variablen rechts des Gleichheitszeichens bestimmt den Datentyp der Variable links des Gleichheitszeichens.• Mit Variablen können Operationen durchgeführt werden. Auf Variablen mit numerischem Datentyp (int, float) können Sie arithmetische Operationen und Vergleichsoperationen anwenden, Variablen vom Typ str können mit dem Operator + zusammengesetzt werden und sie können ebenfalls miteinander verglichen werden.• Variablen vom Typ bool können nur die Werte True oder False annehmen• Der Typ von Variablen kann mit type(Variablenname) abgefragt werden• Einer Variablen kann mit = jederzeit ein neuer Wert zugewiesen werden. Hat dieser Wert einen anderen Datentyp, ändert sich auch der Datentyp der Variablen.• Der Inhalt von Objekten des Typs int, float, bool und str ist unveränderlich. Wird einer Variablen, die auf ein solches Objekt verweist, ein neuer Wert zugewiesen bedeutet das, dass intern ein neues Objekt erzeugt wird. Der Variablenname bleibt dabei gleich.4 KommentareProgrammcode ist nicht immer leicht zu verstehen und selbsterklärend. Dies gilt besonders für umfangreiche und komplexe Programme. Sie sollten Sich daher angewöhnen, Ihren Programmcode mit Kommentaren zu dokumentieren. In diesem Kapitel lernen Sie zwei Arten von Kommentaren kennen.4.1 Verschiedene Möglichkeiten für KommentareWenn irgendwo in einer Zeile eine Python-Programms ein #-Zeichen steht, ignoriert der Python-Interpreter alles, was in dieser Zeile danach kommt. Das #-Zeichen leitet einen Kommentar ein.Wenn Kommentare sich über mehrere Zeilen erstrecken sollen, muss entweder am Anfang jeder Kommentar-Zeile das #-Zeichen stehen oder können Sie können auch mit drei Anführungszeichen begonnen und abgeschlossen werden. Im folgenden Beispiel sehen Sie alle drei Möglichkeiten."""Dies ist ein Block-Kommentar über mehrere Zeilen:Variablen können in Python an irgendeiner Stelle eines Programms erzeugt und danach verwendet werden. Die folgenden Beispiele zeigen dies für Zahlen und Zeichenketten """betrag = 155print(betrag)  # Einzel-Kommentar nach dem Code in einer Zeilestueckzahl = 60# Einzel-Kommentar über eine Zeile# Für jede neue Kommentarzeile muss ein # am Anfang der Zeile stehenstueckpreis = betrag / stueckzahlprint(stueckpreis)4.2 Wieviel Kommentar ist angemessen?Wenn Sie grössere und komplexe Programme schreiben, sollten Sie genügend Anmerkungen einbauen, die das Verständnis des Codes erleichtern können. Dies gilt für andere Menschen, die Ihren Code lesen müssen, aber auch für Sie selbst. Wer kann sich schon nach Tagen, Wochen oder Monaten noch an alle Gedanken erinnern, die beim Programmieren eine Rolle gespielt haben? Kommentieren Sie zu Anfang viel und ausführlich, erklären Sie sich sozusagen selbst, was in Ihrem Code passiert.Auf der anderen Seite ist es nach einiger Zeit nicht mehr sinnvoll, jede kleine Sequenz von Anweisungen zu kommentieren. Irgendwann haben Sie genug Python-Kenntnisse, um Ihren Code auch ohne Kommentare zu verstehen und ein ausuferndes kommentieren von Selbstverständlichkeiten macht ihn unübersichtlich.5 Funktionen benutzenProgrammcode erfüllt oft immer wiederkehrend die gleichen Aufgaben und es wäre mühsam, dafür jedes Mal die gleichen Anweisungen eingeben zu müssen. Vermieden werden kann das durch die Verwendung von Funktionen. Python bringt bereits eine Reihe eingebauter Funktionen mit, die Sie benutzen können Mit der sogenannten Standardbibliothek von Python steht Ihnen darüber hinaus eine umfangreiche Sammlung von vordefinierten Funktionen für die häufigsten Anwendungszwecke zur Verfügung.5.1 LernzieleNach der Bearbeitung dieses Kapitels können Sie• Beschreiben, was eine Funktion ist• Die Signatur einer Funktion verstehen• Eingebaute Funktionen und Funktionen aus der Standardbibliothek in Ihren Programmen nutzen• Die ersten Python-Programme schreiben5.2 Was ist eine Funktion?Eine Funktion ist ein Stück bestehender Programmcode, das Sie als Programmierer benutzen können ohne den genauen Inhalt zu kennen. Es reicht, wenn Sie wissen, was die Funktion tut und wie ihre Signatur ist. Die Signatur einer Funktion hat die folgenden Bestandteile:Rückgabewert = Funktionsname ( Parameter1,  Parameter2, . . . , Parametern  )• Der Funktionsname bezeichnet die Funktion eindeutig.• Die Liste der Parameter. Sie werden in den Klammern nach dem Funktionsnamen mit Kommas getrennt geschrieben und sind der Input für die Funktion. Je nach Funktion ist Ihre Anzahl und ihr Datentyp unterschiedlich festgelegt. Wird eine Funktion benutzt, nennt man die Werte oder Variablen, die an die Funktion übergeben werden Argumente. Beispiele dafür sind:print( 'Dies ist ein Argument')print( zahl )• Manche Funktionen wie print() haben eine variable Anzahl von Parametern und können mit beliebig vielen Argumenten aufgerufen werden. • Manche Funktionen verändern den Wert von Variablen, die als Parameter übergeben wurden. Es gibt auch Funktionen ohne Parameter, diese werden dann mit ohne Argumente «funktions_name()» aufgerufen.• Der Rückgabewert ist das primäre Ergebnis der Funktion. Er hat einen Datentyp, der von Funktion zu Funktion unterschiedlich ist. Manche Funktionen liefern aber keinen interessanten Rückgabewert – Sie geben dann den speziellen Wert None zurück.Zunächst sollten Sie bereits verfügbare Funktionen benutzen, die in der sogenannten Standardbibliothek stehen. Im Verlauf dieses Kurses werden Sie dann weitere Funktionen benutzen, die aus verschiedenen verfügbaren Modulen stammen und schliesslich werden Sie auch eigene Funktionen schreiben und benutzen. 5.3 Die Funktionen print() und input()Python enthält Funktionen für die Ein- und Ausgabe von Text. Die erste Funktion, die sie beim Programmieren brauchen werden, ist print(). Sie gibt die Argumente in den Klammern auf den Bildschirm aus.>>> text1 = 'Die höhere Fachschule'>>> anzahl = 100>>> print(text1)Die höhere Fachschule>>> print(anzahl)100>>> print(text1, 'hat', anzahl, 'Studierende')Die höhere Fachschule hat 100 StudierendeArgumente von print() können Variablen, aber auch Literale sein. Stehen mehrere Argumente durch Kommas getrennt in den Klammern, werden sie nacheinander mit einem Leerzeichen dazwischen ausgegeben. Die Anzahl der Parameter von print() ist variabel:>>> print('Der Inhalt von liste1 ist:', liste1)Der Inhalt von liste1 ist: [1, 2, 3, 4, 5]>>> print("Der Text in Variable 'text1' ist", 21, 'Zeichen lang')Der Text in Variable 'text1' ist 21 Zeichen langDie Funktion print() hat den Rückgabewert None und sie ändert keine Werte Ihrer Parameter. Sie wird ausschliesslich wegen Ihrer Wirkung (Textausgabe) benutzt. Sie benötigen print(), wenn Sie nicht mehr nur Eingaben in der REPL machen zur Ausgabe verschiedener Informationen.Zur Eingabe kann die Funktion input() verwendet werden. Die Funktion liefert dann die eingegebenen Zeichen als String zurück. Wird in den Klammern ein Text angegeben, wird dieser als Prompt ausgegeben:>>> eingabe_name = input('Geben Sie Ihren Namen ein --> ')Geben Sie Ihren Namen ein --> Hans>>> eingabe_name'Hans'Die Funktion input() hat einen Parameter (den Prompt vom Typ str) und einen Rückgabewert, nämlich die Zeichenkette, die Sie eingegeben haben (Typ str)5.4 Typen anzeigen und umwandelnIn der REPL sehen Sie, dass der Rückgabewert von input() immer eine Zeichenkette ist, auch wenn Sie eine Zahl eingeben:>>> eingabe_alter = input('Geben Sie Ihr Alter ein --> ')Geben Sie Ihr Alter ein --> 30>>> eingabe_alter'30'Wird eine ganze Zahl benötigt, muss dieser String zunächst umgewandelt werden. Dafür kann int(string) verwendet werden, die als Argument einen String erwartet, der eine Zahl repräsentiert:>>> alter = int(eingabe_alter)>>> alter30Mit type(variable) kann man sich den Datentyp eines Objekts ansehen:>>> type(alter)<class 'int'>>>> type(eingabe_alter)<class 'str'>Die Eingabe des Alters und das Umwandeln in eine ganze Zahl kann auch wie folgt zusammengezogen werden:>>> alter = int(input('Geben Sie Ihr Alter ein --> '))Geben Sie Ihr Alter ein --> 30>>> alter30Als Argument einer Funktion kann also wiederum eine Funktion stehen. Die Funktion input() liefert ein String-Objekt zurück, das dann von int() als Argument verarbeitet wird.5.5 Weitere nützliche eingebaute FunktionenIn diesem Abschnitt finden Sie einige weitere nützliche Funktionen, die in der Sprache Python eingebaut sind:help()help( <object> )Gibt in der REPL einen Hilfetext aus. Ohne Angabe eines Arguments wird das interaktive Hilfesystem gestartet. Mit einem Argument wird gezielt ein Hilfetext zu object ausgegeben, wobei object eine Funktion, ein String, ein Schlüsselwort oder ein anderes Thema sein kann:>>> helpType help() for interactive help, or help(object) for help about object.>>> help(input)Help on built-in function input in module builtins:input(prompt=None, /)    Read a string from standard input.  The trailing newline     is stripped.        The prompt string, if given, is printed to standard output     without a trailing newline before reading input.        If the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return),     raise EOFError.    On *nix systems, readline is used if available.(END)float( <String oder Zahl> )float()Die Funktion float(String oder Zahl) akzeptiert als Argument eine Variable oder ein Literal, das eine Zeichenkette oder eine Zahl als Wert hat und gibt als Rückgabewert eine Fliesskommazahl zurück, wenn die Zeichenkette korrekt in eine Zahl umgewandelt werden kann. Wird kein Argument angegeben, gibt float() den Wert 0.0 zurück. Beispiele für die Verwendung von float():>>> zahl = 11>>> zahlwort = 123.45>>> float(zahl)11.0>>> float(zahlwort)123.45>>> float('22.3')22.3>>> float('22,3')Traceback (most recent call last):  File "<stdin>", line 1, in <module>ValueError: could not convert string to float: '22,3'Die Umwandlung von str zu float funktioniert nur, wenn in der Zeichenkette ein Dezimalpunkt statt eines Dezimalkommas verwendet wird.string( object )Wandelt den Wert von object in eine passende Repräsentation als Zeichenkette um (wenn das möglich ist) und gibt eine Referenz zum resultierenden String-Objekt zurück. Beispiel:>>> preis = 123.99>>> preis_string = str(preis)>>> text = 'Der Preis ist ' + preis_string>>> text'Der Preis ist 123.99'>>>len( object )Ist der Parameter object eine Zeichenkette, gibt die Funktion die Länge der Zeichenkette zurück.Beispiel:>>> text1 = 'Höhere Fachschule'>>> wort_länge = len(text1)>>> wort_länge 17max( object, object, . . . )Gibt das grösste von mehreren Objekten in einer Aufzählung als Wert zurück. Die Objekte in der Parameterliste müssen dafür aber miteinander vergleichbar sein.Beispiele:>>> max( 12, 78.9, 2 )78.9>>> max('Z', 'z', 'A', 'a')'z'>>> max('Anfang', 'Ende')'Ende'>>> max('Anfang', 'Ende', 112)TypeError: '>' not supported between instances of 'int' and 'str'min( object, object, . . . )Gibt das kleinste von mehreren Objekten in einer Aufzählung als Wert zurück. Die Objekte in der Parameterliste müssen dafür aber miteinander vergleichbar sein.5.6 Funktionen als FunktionsparameterDie Funktion int(object) haben Sie bereits im  Beispiel zur Funktion input(Prompt) kennengelernt. Dort wurde eine Zahl eingelesen. Da input() immer eine Zeichenkette zurückliefert, muss diese vor der Weiterverwendung erst einmal in eine Zahl umgewandelt werden:>>> >>> eingabe_alter = input('Geben Sie Ihr Alter ein --> ')Geben Sie Ihr Alter ein --> 30>>> alter = int(eingabe_alter)Die Eingabe des Alters und die Umwandlung in eine ganze Zahl kann auch wie folgt zusammengezogen werden:>>> alter = int( input('Geben Sie Ihr Alter ein --> ') )Geben Sie Ihr Alter ein --> 30>>> alter30Ein Argument einer Funktion kann also wiederum eine Funktion sein, solange sie einen passenden Rückgabewert liefert. Die innere Funktion input() wird ausgeführt und ihr Rückgabewert wird als Argument der äusseren Funktion int() eingesetzt.Sie werden häufiger solche ineinander verschachtelten Funktionsaufrufe sehen, teilweise mit drei oder noch mehr Funktionen, die ineinander verschachtelt sind. Sie werden immer schrittweise von innen nach aussen ausgeführt und sollte auch so gelesen werden. 5.7 Zusammenfassung• Eine Funktion ist ein Stück Programmcode, das einen Namen hat. Durch die Benutzung des Funktionsnamens kann dieser Programmcode an verschiedenen Stellen eines Programms verwendet werden. Sie müssen den Code der Funktion nicht kennen, sondern nur ihren Zweck und die Signatur der Funktion. Diese umfasst den Namen, die Parameter und den Datentyp des Rückgabewerts.• Parameter ermöglichen es, einer Funktion Werte bzw. Objekte zu übergeben. Wenn man Funktionen aufruft, übergibt man diesen Funktionen Argumente in der Form Funktion ( Argument, Argument, …).• Viele Funktionen haben einen Rückgabewert, das heisst, sie können auf der rechten Seite einer Zuweisung stehen, aber auch selbst wieder als Argument einer anderen Funktion auftreten:Variable = Funktion( Argumente )Variable = Funktion ( Funktion( Argumente) )• Die Dokumentation aller in Python eingebauten Funktionen finden Sie unter https://docs.python.org/3/library/functions.html • Weitere Funktionen können aus sogenannten Modulen der Standardbibliothek stammen, von anderen Programmieren bereitgestellt oder von Ihnen selbst geschrieben sein. Zu den weiteren Modulen der Standardbibliothek und zum Thema eigene Funktionen erfahren Sie mehr in späteren Kapiteln.5.8 AufgabenProgrammieren lernen Sie nur durch Programmieren. Ab diesem Kapitel finden sie jeweils kleinere und grössere Programmieraufgaben. Die folgenden Programme erstellen Sie statt in der REPL im Editor von Visual Studio Code und speichern sie. Führen Sie die Programme mit Rechtsklick und Auswahl «Run Python File in Terminal» aus (Die ausführliche Beschreibung finden Sie in Kapitel 1.6).1) Schreiben Sie die Programme summe.py, differenz.py, multiplikation.py und division.py, die jeweils zwei Zahlen abfragen, eine Rechenoperation ausführen und das Ergebnis ausgeben. Sie sollen für Eingaben von ganzen Zahlen und für Zahlen mit Nachkommastellen funktionieren, wobei statt des Dezimalkommas ein Punkt verwendet werden soll. Ein Beispiel für die Ausführung von multiplikation.py:$ python multiplikation.pyZwei Zahlen multiplizierenZahl1: 2Zahl2: 12.525.02) Schreiben Sie das Programm mittelwert.py, das jeweils zwei Zahlen abfragt und den Mittelwert dieser Zahlen ausgibt. Ein Beispiel für die Ausführung:$ python mittelwert.py"Mittelwert von zwei Zahlen berechnenZahl1: 6.0Zahl2: 129.03) Schreiben Sie ein Programm rechteck_fläche.py, das die Höhe und die Breite eines Rechtecks in cm abfragt und die Fläche in cm2 ausgibt:$ python rechteck_flaeche.pyFläche eines Rechtecks in QuadratzentimeterLänge in cm: 20Breite in cm: 10Fläche in Quadratzentimeter: 200.0$4) Schreiben Sie ein Programm kreis_fläche.py, das den Durchmesser eines Kreises in cm abfragt und die Fläche in cm2 nach der Formel Fläche = π * Radius2 berechnet und ausgibt. Nehmen Sie für die Zahl π den gerundeten Wert 3.1416 an.$ python kreis_flaeche.pyFläche eines Kreises in QuadratzentimeterDurchmesser in cm: 10Fläche in Quadratzentimeter: 78.53999999999999$5) Für einen festen Kapitalbetrag KAnfang , der über J Jahre zu einem Zinssatz Z verzinst wird, berechnet sich der Endbetrag KEnde nach der Zinseszins-Formel:KEnde = KAnfang * ( 1 + Z/100)JahreSchreiben Sie ein Programm verzinsung.py, das als Eingaben den Anfangsbetrag, den Zinssatz und die Anzahl Jahre bekommt und das den Enbetrag ausgibt:$ python zinseszins1.pyKapitalbetrag nach Verzinsung über eine Anzahl JahreAnfangskapital: 100Zinssatz in %: 5Anzahl Jahre: 10Kapital nach 10.0 Jahren 162.8894626777442$6 Programme mit VerzweigungenMittlerweile haben Sie bereits sehr viele Grundlagen von Python kennengelernt:• Sie wissen, was Literale, Variablen, Datentypen und Operatoren sind • Sie können Anweisungen wie die Zuweisung eines Werts an eine Variable oder Berechnungen ausführen• Sie können Funktionen aus der Standardbibliothek nutzen, diesen Funktionen Parameter übergeben und Sie wissen, dass manche Funktionen einen Wert zurückliefern, den Sie wiederum in einer Variablen speichern können.Diese Dinge haben Sie bisher mit einzelnen Eingaben in der REPL von Python ausprobiert und Ihre Eingaben wurden nicht für eine spätere Verwendung gespeichert. Mit diesem Kapitel beginnen Sie, komplette Programme zu schreiben, die Sie speichern und zu einem späteren Zeitpunkt immer wieder ausführen können.6.1 LernzieleNach der Bearbeitung dieses Kapitels können Sie• Den Begriff Algorithmus erklären• Einen Entwurf für den Ablauf eines Programms erzeugen• Ein komplettes Programm mit Visual Studio-Code schreiben, speichern und ausführen• Den Ablauf des Programms mit if, else und elif steuern• Das Programm mit sinnvollen Testdaten testen6.2 Ein Python Programm entwerfen, erzeugen und testenBeginnend mit diesem Kapitel ist es sinnvoll, dass Sie zusätzlich zu der der REPL den Editor in Visual Studio Code benutzen. Eine Anleitung dafür finden Sie in Kapitel 1.6. 6.3 EntwurfSie könnten natürlich sofort mit dem Programmieren im Editor beginnen. Besser ist es aber, wenn Sie sich zunächst einen Plan zu machen, der folgende Fragen beantwortet:• Was ist der Zweck des Programms? • Was sind die möglichen Eingaben und was sind die erwarteten Ausgaben des Programms?• Wie ist der Ablauf im Programm?• Welche Bestandteile der Programmiersprache sollen eingesetzt werden?Dies gilt besonders dann, wenn Sie gerade das Programmieren mit Python (oder irgend einer anderen Programmiersprache) erlernen, denn einerseits müssen Sie sich überlegen, wie das Problem prinzipiell gelöst werden kann und andererseits müssen Sie die Mittel einer für Sie neuen Programmiersprache richtig anwenden. Anstatt sich auf beide Aspekte gleichzeitig zu konzentrieren, sollten Sie diese trennen. Gewöhnen Sie sich am besten gleich folgendes Vorgehen für alle Programmierprojekte an:• Zuerst machen Sie einen Entwurf, am besten auf einem Blatt Papier.• Erst danach fangen Sie an zu programmieren und zu testen• Programmieren Sie in kleinen Schritten. Setzen Sie zunächst eine Teilaufgabe um. Wenn sie das Programm erfolgreich getestet haben, ergänzen Sie das Programm mit der nächsten Teilaufgabe.Unser Programm soll gerade.py heissen und es soll ausgeben, ob eine eingegebene Zahl gerade oder ungerade ist. Der Entwurf für das Programm gerade.py:• Zweck des Programms: Prüfung ob eine beliebige Zahl gerade oder ungerade ist• Mögliche Eingaben: Eine ganze Zahl• Erwartete Ausgabe: Information, ob die Zahl gerade oder ungerade ist.• Ablauf (Algorithmus) Ein Algorithmus ist eine eindeutige Handlungsvorschrift zur Lösung einer Aufgabe. Kern der Lösung in unserem Programm ist eine Prüfung , ob die Zahl ohne Rest durch 2 teilbar ist. Ein Algorithmus kann grafisch dargestellt werden:Abbildung 61 Diagramm zur Darstellung des Algorithmus für das Programm gerade.py• Der Algorithmus für gerade.py kann aber auch als einfacher Text beschrieben werden:1. Nehme eine ganze Zahl als Eingabe2. Teile Sie durch 23. Prüfe, ob der Divisionsrest 0 ist4. Wenn der Divisionsrest 0 ist, gebe die Meldung «Die Zahl ist gerade» aus5. Ansonsten gebe die Meldung «Die Zahl ist ungerade» aus• Der nächste Schritt im Entwurf ist die Überlegung, welche Mittel der Sprache Python Sie bereits kennen, um den Algorithmus in ein Programm umzusetzen:1. Eingabe einer Zahl: Sie kennen die Funktion input() und wissen, dass Sie das Ergebnis von input() mit int() in eine ganze Zahl umwandeln und dieses Ergebnis wiederum einer Variablen zuweisen können.2. Beim Teilen durch 2 interessiert Sie das Ergebnis eigentlich nicht, Sie möchten eigentlich nur wissen, ob der Divisionsrest 0 ist. Den Divisionsrest ermitteln sie mit dem Modulo-Operator %3. Für Prüfung ob, der Rest 0 ist können Sie den Vergleichsoperator == benutzen.4. Wie können Sie das «Wenn» in einem Programm umsetzen? An dieser Stelle fehlt Ihnen noch etwas. Sie brauchen ein Werkzeug zur Steuerung des Programmflusses – Dazu gibt es gleich mehr Informationen …5. Die Ausgaben können Sie mit der Funktion print() machen.6.4 Die Programmierung von gerade.pyDas Programm könnte - nach dem was Sie bis jetzt wissen - folgendermassen aussehen:1  # Die Eingabe holen2  eingabe = input("Bitte geben Sie eine ganze Zahl ein: ")3  # Die Eingabe in eine Ganzzahl umwandeln4  zahl = int(eingabe)5  # Den Divisionsrest beim Teilen durch 2 bestimmen 6  rest = zahl % 27  8  # Hier kommt das was passiert  "Wenn der Rest 0 ist"9..print("Die Zahl", zahl, "ist gerade")10  11  # Hier kommt das was passiert  "Wenn der Rest nicht 0 ist"12  print("Die Zahl", zahl, "ist ungerade")6.5 Den Programmfluss mit if steuernDas, was Sie für die Fertigstellung Ihres Programms noch benötigen heisst in Python «if». Wann immer Sie prüfen müssen, ob eine Bedingung erfüllt ist und abhängig von dem Ergebnis dieser Prüfung unterschiedliche Aktionen ausführen wollen, können sie dies mit der folgenden Struktur tun:Abbildung 62 Struktur eines Programms mit ifNach dem Schlüsselwort if kommt eine Bedingung. Eine Bedingung nach if muss als Ergebnis einen Wert von Typ bool haben, also entweder True oder False. In unserem Fall wäre das die Bedingung Divisionsrest == 0.Nach der Bedingung kommt ein Doppelpunkt und die drei Zeilen danach sind nach rechts eingerückt. Die Anweisungen 1 bis 3 gehören durch die Einrückung zusammen. Sie werden ausgeführt, wenn die Bedingung erfüllt, also True ist. Danach werden die Anweisungen 4 und 5 ausgeführt.Ist die Bedingung nicht erfüllt, also das Ergebnis des Vergleichs False, werden die Anweisungen 1 bis 3 nicht ausgeführt. Stattdessen geht der Programmfluss direkt bei Anweisung 4 weiterAbbildung 63 Programmfluss, wenn die Prüfung der Bedingung True oder False ergibtAufeinander folgende Anweisungen in der gleichen Einrückungstiefe nennt man in Python eine Suite. Nach dem Doppelpunkt hinter if erwartet Python eine um mindestens ein Leerzeichen eingerückte Anweisung oder mehrere aufeinanderfolgende Anweisungen in der gleichen Einrückungstiefe. Die Empfehlung ist, pro Einrückungsebene vier Leerzeichen zu benutzen. Der Editor von Visual Studio Code macht automatisch eine solche Einrückung nach einer Zeile, die mit einem Doppelpunkt endet.In unserem Programm wird nur eine einzige Anweisung nach if in Zeile 5 gebraucht. Die neue Suite beginnt in Zeile 6 besteht also nur aus einer einzigen Zeile: 1  eingabe = input("Bitte geben Sie eine ganze Zahl ein: ") 2  zahl = int(eingabe) 3  rest = zahl % 2 4   5  if rest == 0: 6      print("Die Zahl", zahl, "ist gerade")Erzeugen Sie das Programm gerade.py und führen Sie es aus (Rechtsklick auf den Namen des Programms, dann «Python-Datei im Terminal ausführen» auswählen). Im unteren Teil des Hauptfensters erscheint die Terminalausgabe. Probieren Sie es mit geraden und ungeraden Zahlen aus. Das Ergebnis sollte so aussehen:$ python gerade.pyBitte geben Sie eine ganze Zahl ein: 44Die Zahl 44 ist gerade$ python gerade.pyBitte geben Sie eine ganze Zahl ein: 45$6.6 if mit else erweiternNun wäre es schön, wenn das Programm auch noch eine Ausgabe machen würde, wenn die Zahl ungerade ist. Eine Möglichkeit dazu wäre, eine zweite Prüfung mit if einzubauen: 1  eingabe = input("Bitte geben Sie eine ganze Zahl ein: ") 2  zahl = int(eingabe) 3  rest = zahl % 2 4   5  if rest == 0: 6      print("Die Zahl", zahl, "ist gerade") 7  if rest == 1: 8      print("Die Zahl", zahl, "ist ungerade")Es geht aber auch eleganter, indem Sie das Schlüsselwort else («Ansonsten») benutzen. In der Formulierung des 5. Schritt im Algorithmus hiess es ja schliesslich:‘ Ansonsten gebe die Meldung «Die Zahl ist ungerade» aus ’Die grundsätzliche Struktur eines Programms mit if und else sehen Sie in der folgenden Abbildung:Abbildung 64 Grundsätzliche Struktur if und elseNach else kommt wieder ein Doppelpunkt und eine zweite Suite von zwei Anweisungen mit der gleichen Einrückungstiefe. Ist Die Bedingung erfüllt, also das Ergebnis der Prüfung True, werden Anweisung 1, 2 und 5 ausgeführt. Ist das Ergebnis False werden die Anweisungen 3, 4 und 5 ausgeführt.Abbildung 65 Programmablauf bei if mit else in zwei FällenDas Programm gerade.py, erweitet um else sieht damit so aus: 1  eingabe = input("Bitte geben Sie eine ganze Zahl ein: ") 2  zahl = int(eingabe) 3  rest = zahl % 2 4   5  if rest == 0: 6      print("Die Zahl", zahl, "ist gerade") 7  else: 8      print("Die Zahl", zahl, "ist ungerade")Ergänzen Sie Ihre bisherige Programm-Version mit else und testen Sie sie mit geraden und ungeraden Zahlen.Verschachtelte BedingungenProgramme müssen häufig mehr als zwei Fälle unterscheiden. Betrachten Sie folgendes Beispiel einen Algorithmus für die Berechnung des Eintritts für ein Museum:1. Kinder im Alter bis zur sechs Jahren bezahlen keinen Eintritt2. Kinder und Jugendliche im Alter von über sechs und bis zu 17 Jahren zahlen den halben Eintritt3. Erwachsene zahlen den vollen Eintritt4. Rentner ab 65 zahlen 75% des vollen EintrittsDer Algorithmus als Text dargestellt lautet:1. Setze den Normalpreis fest2. Frage das Alter ab3. Prüfe, ob das Alter kleiner als 6 Jahre ist. Wenn ja, setze die Ermässigung für den Eintritt auf 100% 4. Ansonsten prüfe, ob das Alter kleiner als 18 Jahre ist. Wenn ja, setze die Ermässigung für den Eintritt auf 50%5. Ansonsten prüfe, ob das Alter kleiner als 65 Jahre ist. Wenn ja, setze die Ermässigung für den Eintritt auf 0%6. Ansonsten setze die Ermässigung für den Eintritt auf 75%7. Multipliziere den Normalpreis mit der Ermässigung
Der Algorithmus kann stattdessen auch grafisch dargestellt werden:Abbildung 66 Grafische Darstellung der Berechnung des EintrittsDie Mittel der Programmiersprache, die sie im Programm einsetzen können sind:• Eine Zuweisung des Normalpreises als float-Wert an eine Variable normalpreis• Eine Zuweisung der Ermässigung an eine andere Variable. Statt die Prozentwerte 0%, 50%, 75% und 100% zu benutzen, können Sie auch die float-Werte 0.0, 0.5, 0.75, und 1.0 verwenden und diese einer Variablen faktor zuweisen• Die Funktion input() für die Eingabe des Alters, die mit der Funktion int() in eine ganze Zahl umgewandelt wird und anschliessend einer Variablen alter zugewiesen wird.• Eine Reihe von if- und else-Anweisungen, mit denen Sie den inhalt der Variablen alter prüfen und je nach dem Ergebnis den Inhalt der Variablen faktor setzen• Eine Anweisung am Ende, die die Variablen normalpreis und faktor multipliziert und das Ergebnis mit der Funktion print() ausgibt.
In einem Python-Programm könnte das folgendermassen umgesetzt werden: 1  """ 2  eintritt1.py demonstriert das Verschachteln mehrerer if und 3  else Bedingungen. Nach jedem Doppelpunkt beginnt eine neue Suite, 4  die jeweils weiter nach rechts eingerueckt werden muss 5  """ 6  normalpreis = 20.0 7  faktor = 1.0 8  alter = int( input("Alter: ")) 9  10  if alter < 6:11      faktor = 0.012  else:13      if alter < 18:14          faktor = 0.515      else:16          if alter < 65:17              faktor = 1.018          else:19              faktor = 0.7520  21  print("Der Eintritt kostet:", normalpreis * faktor)Die Einrückungen im Programmbeispiel dienen nicht nur der besseren Lesbarkeit. Im Gegensatz zu anderen Programmiersprachen beeinflussen Einrückungen in Python den Programmablauf. In einer Suite, die nach einer if-Bedingung oder nach else: beginnt, kann jederzeit eine weitere Suite beginnen. In Python muss diese erneut eingerückt werden. • Der erste Doppelpunkt steht nach der if-Bedingung in Zeile 10 • Die folgende Suite hat nur diese eine Zeile (Zeile 11). • Die Zeile 12 ist wieder auf der gleichen Ebene wie die Zeilen 1-10 . • In Zeile 13 beginnt eine weitere Suite. Dazu gehören die Zeilen 13 und 15. • Zur Suite, die mit Zeile 16 beginnt gehört auch die Zeile 18. Die Zeilen 17 und 19 bilden jeweils eine eigene Suite.Zeilen, die die gleiche Einrückungstiefe haben, gehören also logisch zusammen. Die Einrückungstiefe innerhalb einer Suite muss genau eingehalten werden, weil der Python-Interpreter daran erkennt, welche Anweisungen zur Suite gehören. Der Editor von Visual Studio Code zeigt die zusammengehörigen Anweisungen einer Suite durch Linien im Hintergrund an:Abbildung 67 Linien im Editor zeigen Suiten anVerschachtelte Bedingungen mit elifBei nur vier Fällen, die es zu unterscheiden gilt sind die verschachtelten if … else Anweisungen aus dem vorigen Abschnitt noch halbwegs übersichtlich. Wenn es aber mehr als einige wenige Verschachtelungsebenen gibt und wenn die Codezeilen länger werden ist es sinvoller die Schreibweise mit elif zu benutzen. Das Schlüsselwort elif zieht else und if zusammen und mehrere elif hintereinander können auf der gleichen Einrückungstiefe stehen.Das Programm eintritt2.py sieht bei der Verwendung von elif folgendermassen aus: 1  """ 2  eintritt2.py demonstriert die Benutzung von elif 3  Die Funktionalität ist die gleiche wie bei eintritt1.py, 4  aber der Code sieht nun übersichtlicher aus 5  """ 6   7  voller_preis = 20.0 8  eintritt = voller_preis 9  alter = int( input("Alter: "))10  11  if alter < 6:12      eintritt = 0.013  elif alter < 18:14      eintritt = voller_preis * 0.515  elif alter < 65:16      eintritt = voller_preis17  else:18      eintritt = voller_preis * 0.7519  20  print("Der Eintritt kostet:", eintritt)6.7 Verknüpfung mehrerer BedingungenEine neue Anforderung an das Programm zur Berechnung des Eintritts ist: Studenten zwischen 18 und 40 Jahren sollen einen zusätzlichen Rabatt erhalten. Für diesen Fall wird eine weitere Abfrage eingebaut: 1 ist_student = False 2 alter = int( input("Alter: ")) 3 if alter > 17 : 4    if alter < 41 : 5        antwort = input("Sind sie Student? (J/N)") 6        if antwort == 'J': 7            ist_student = True 8 print("Ist Student: ", student)Die zwei Bedingungen werden im obigen Beispiel durch zwei geschachtelte if – Anweisungen geprüft. Eine andere Möglichkeit ist, sie mit dem Schlüsselwort and zu verknüpfen: 3  if alter > 17 and alter < 41 : 4      antwort = input("Sind sie Student? (J/N)") 5      if antwort == 'J': 6          ist_student = TrueWenn beide Bedingungen (alter > 17 und alter < 41) den Wert True ergeben, ergibt die Kombination der beiden Bedingungen auch True und die Suite, die in Zeile 4 beginnt, wird ausgeführt. Eine weitere Verknüpfung von zwei Bedingungen könnte auch nach der Abfrage «Sind Sie Student?» hilfreich sein. Dort muss der Benutzer ein grosses «J» eingeben, damit der Status «ist_student = True» gesetzt wird. Der Inhalt der Variablen «antwort» in Zeile 4 könnte zusätzlich auf ein kleines «j» geprüft werden, was das Programm etwas anwenderfreundlicher machen würde. Dafür brauchen wir aber eine Verknüpfung mit or statt and:3  if alter > 17 and alter < 41 :4      antwort = input("Sind sie Student? (J/N)")5      if antwort == 'J' or antwort == 'j':6          ist_student = TrueBei der Verknüpfung von zwei Bedingungen mit or muss nur eine der beiden Bedingungen erfüllt sein, damit die gesamte Bedingung hinter if True ergibt. Die beiden folgende Tabellen zeigen die Regeln für die Verknüpfung mit  and und or:Bedingung 1 ergibt:Verknüpfung mitBedingung 1 ergibt:ErgebnisTrueandTrueTrueTrueFalseFalseFalseTrueFalseFalseFalseFalseAbbildung 68 Verknüpfung logischer Bedingungen mit andBedingung 1 ergibt:Verknüpfung mitBedingung 1 ergibt:ErgebnisTrueorTrueTrueTrueFalseTrueFalseTrueTrueFalseFalseFalseAbbildung 69 Verknüpfung logischer Bedingungen mit or6.8 Zusammenfassung• Die ersten drei Schritte der Softwareentwicklung sind Analyse, Entwurf und Implementierung. In der Analyse versteht der Entwickler die zu lösende Aufgabe, im Entwurf plant er, wie er die Aufgabe lösen will und in der Implementierung schreibt und testet er Programmcode. Nicht nur für Programier-Neulinge ist es unbedingt empfehlenswert, sich die Zeit für einen Entwurf ( vorzugsweise ohne Computer ) zu nehmen.• Programme werden als Textdatei mit der Endung .py erfasst, abgespeichert und dann vom Python-Interpreter ausgeführt.• Mit den Schlüsselwörtern if, else und elif können Sie den Programmfluss abhängig von Bedingungen steuern• Nach if oder elif steht entweder eine einfache logische Bedingung oder es stehen dort mehrere Bedingungen, die mit and bzw. or kombiniert werden• Danach kommt ein Doppelpunkt. Er leitet eine eingerückte Suite von Anweisungen ein, die ausgeführt werden, wenn die Prüfung der Bedingung(en) True ergeben hat• Optional schliesst sich an diese Suite das Schlüsselwort else, gefolgt von einem Doppelpunkt an. Darauf folgt eine Suite von Anweisungen ein, die ausgeführt werden, wenn die Prüfung der Bedingung(en) False ergeben hat.• Die Tiefe der Einrückung einer Suite hat eine Bedeutung für die Programmlogik und muss strikt eingehalten werden.• Bedingungen können beliebig tief verschachtelt werden und das Schlüsselwort elif ermöglicht in solchen Fällen die Zusammenfassung von else: if und eine etwas übersichtlichere Darstellung mit weniger Einrückungen.
6.9 AufgabenVorbemerkungDer Entwurf kommt vor der Implementierung. Machen Sie sich bei den Programmieraufgaben vor der eigentlichen Programmierung immer zuerst einen Plan: Was sind die Anforderungen an das Programm? Was sind die Eingaben? Welche Ausgaben werden erwartet? Wie ist der Algorithmus (Ablauf als Text oder Zeichnung oder beides)? Welche Python-Sprachbestandteile kennen Sie schon und welche davon könnten1) Welche Eingabewerte / Testfälle sind geeignet, um die Korrektheit der Programme eintritt1.py, eintritt2.py und eintritt3.py zu überprüfen? Listen Sie die Werte auf, die für einen Test mindestens gebraucht werden. Kümmern Sie sich dabei noch nicht um Falscheingaben (z.B. Text statt Zahlen)2) Für die Lohnabzüge für eine Sozialversicherung sollen die folgenden Regeln gelten:• Der Beitrag ist erst auf Jahreslöhne ab 20’000.- zu entrichten• Der Beitrag wird vom Lohn nur bis zu einer Höhe von 120'000.- abgezogen. Lohnanteile über dieser Summe sind beitragsfrei.• Für Löhne über 20'000 und bis zu 80'000.- gilt der Beitragssatz 10%• Für Lohnanteile über 80.000.- gilt der Beitragssatz 5%Schreiben Sie ein Programm beitrag.py, das einen Bruttolohn als Eingabe erhält und den Abzug für den Sozialversicherungsbeitrag berechnet. Beispiele:$ python beitrag.pyBruttolohn: 19999.990$ python beitrag.pyBruttolohn: 800008000.0$ python beitrag.pyBruttolohn: 10000011000.03) Ein Online-Handel für Gartenbedarf verkauft Pflanzenkübel in verschiedenen Formen und Blumenerde. Für die Kübel sind die Masse bekannt, aber nicht das Volumen. Das Programm volumen.py soll dabei helfen, für einen Kübel das Volumen in Liter und damit die benötigten Liter Blumenerde zu berechnen. Die Kübel haben drei verschiedene Formen: Kubus – Die Grundfläche ist rechteckig, die Wände gerade. Das Volumen berechnet sich nach der Formel:V = Länge * Breite * Höhe Zylinder – Die Grundfäche ist rund, oben ist der  Durchmesser Ø gleich wie unten. Das Volumen berechnet sich nach der Formel:V = π * ( Ø / 2 )2 *HöheKegelstumpf – Die Grundfläche unten und oben ist rund, Der Durchmesser Øunten des Bodens ist kleiner als der Durchmesser der Öffnung  Øoben ). Das Volumen berechnet sich nach der Formel:V = Höhe * π /3 * ( Øoben 2 + Øoben * Øunten + Øunten2 ) Die Abmessungen sollen in Zentimeter eingegeben werden. Das Volumen soll in Liter ausgegeben werden. Für die Zahl π benutzen Sie den aufgerundeten Wert 3.142Tipp: Entwerfen und programmieren Sie das Programm in kleinen Schritten. Beginnen Sie mit der Abfrage der benötigten Eingaben für die drei Formen. Statt der Berechnung geben Sie eine Meldung aus, die einfach die gemachten Eingaben wieder ausgibt. Fügen Sie dann die Berechnungen und Ausgaben für eine Form nach der anderen hinzu. 4) Bauen Sie das Programm volumen.py folgendermassen aus:Blumenerde ist in Säcken zu 5, 10 und 20 Liter erhältlich. Der 5-Liter Sack kostet 5.-, der 10-Liter-Sack kostet 8.- und der 20-Liter-Sack 14.-. Stellen Sie je nach Volumen die Säcke so zusammen, dass der Preis für den Kunden am günstigsten ist. 7 Programme mit WiederholungenMit if, else und elif haben Sie bereits mächtige Werkzeuge für die Programmierung in Python an der Hand. Was Ihnen noch fehlt, sind Schleifen. In diesem Kapitel lernen Sie die grundlegende Schleifenform der meisten Programmiersprachen kennen.7.1 LernzieleNach der Bearbeitung dieses Kapitels können Sie• Eine Folge von Anweisungen mit while solange wiederholen, wie Sie wollen• Die Anweisungen break und continue einsetzen7.2 Schleifen mit whileDie Grundform der while-Schleife ist in der folgenden Abbildung dargestellt:Abbildung 71 Struktur der while-SchleifeNach dem Schlüsselwort while folgt eine logische Bedingung. Wenn die Prüfung der Bedingung True ergibt, wird die auf den Doppelpunkt folgende Suite von Anweisungen ausgeführt, dann wird die Bedingung wiederrum geprüft. Das Ganze wiederholt sich, bis die Prüfung der Bedingung False ergibt.Im folgenden Beispiel wird der Wert einer Variablen zahl solange um 1 erhöht, bis der Wert 3 erreicht ist: 1  # countup.py zählt von 0 bis zu einer eingegebenen Zahl 2  zahl = 0 3  zaehlen_bis = int(input("Zählen bis: ")) 4  while zahl < zaehlen_bis: 5      zahl = zahl + 1 6      print(zahl)Ausführung des Programms:$ python countup.py Zählen bis: 3123$Innerhalb einer while-Schleife muss etwas passieren, was das das Ergebnis der logischen Bedingung hinter while verändert. Ansonsten würde die Schleife nie enden. Beachten Sie die folgende, fehlerhafte Version der Schleife: 4  while zahl < zaehlen_bis: 5      ergebnis = zahl + 1 6      print(ergebnis)Die Variablen zahl und zaehlen_bis werden innerhalb der Suite nach while nie verändert, also wird die Prüfung der Bedingung zahl < zaehlen_bis immer True ergeben und die Schleife endet niemals.Tipp: Falls Sie aus Versehen eine Endlos-Schleife programmiert haben, können Sie das Programm beim Testen im Terminal jederzeit mit den Tastenkombinationen Control-C (Strg-C) oder Control-D (Strg-D) abbrechen.7.3 Break, continue und elseMit den Anweisungen break und continue wird das Verhalten einer Schleife beeinflusst. Wird innerhalb der Suite die Anweisung break erreicht, wird die Schleife verlassen. Das Programm countup.py könnte damit so modifiziert werden, dass unabhängig von der eingegebenen Zahl beim Erreichen des Werts 5 nicht mehr weitergezählt wird:Ausführung des Programms:$ python break_demo.pyZählen bis (maximal 5): 190012345Beim Limit 5 ist Schluss$Die while-Schleife kann eine optionale else-Klausel enthalten. Sie enthält Anweisungen, die ausgeführt werden, wenn innerhalb der Schleife eine break-Anweisung enthalten ist, diese aber nicht ausgeführt wird:Ausführung der Schleife mit und ohne Erreichen der break-Anweisung:$ python break_else_demo.pyZählen bis (maximal 5): 190012345Beim Limit 5 ist Schluss$ python break_else_demo.pyZählen bis (maximal 5): 40123Limit wurde nicht erreichtDie Anweisung continue innerhalb einer Schleife bewirkt, dass die darauf folgenden Zeilen nicht ausgegeben werden. Die Schleife wird aber ausgeführt, bis die Bedingung nach while den Wahrheitswert False ergibt:Ausführung des Programms:$ python continue_demo.pyZählen bis: 4010203040$7.4 Zusammenfassung• Mit dem Schlüsselwort while wird eine Wiederholung der Codezeilen in der Suite nach while Bedingung : eingeleitet. • Die Wiederholung erfolgt solange, wie die Bedingung den Wahrheitswert True ergibt. • In der Suite der while-Schleife sollte also etwas passieren, das dafür sorgt, dass die Auswertung der Bedingung irgendwann den Wahrheitswert False ergibt, sonst läuft die Schleife endlos.• Mit der Anweisung break innerhalb einer while-Suite wird die Wiederholung sofort abgebrochen, unabhängig davon, ob die Bedingung nach while noch True liefert.• Wird die Anweisung continue erreicht, springt die Programmausführung sofort an den Schleifenkopf zurück. Anweisungen, die in der Suite nach continue stehen, werden dann nicht ausgeführt• Eine Ergänzung der while-Schleife mit dem Schlüsselwort else: auf der gleichen Einrückungsebene wie das Schlüsselwort while ist möglich. Die Anweisungen nach else: werden nur dann ausgeführt, wenn vorher innerhalb der while-Schleife kein break ausgeführt wurde. Die Verwendung von else: bei while ist nur sinnvoll, wenn in der Schleife eine break-Anweisung steht.7.5 Aufgaben1) Programmieren Sie countdown.py, bei dem der Anwender einen Startwert eingibt. Das Programm zählt ausgehend von diesem Wert bis Null abwärts und gibt statt der Null den Text „Start!“ aus:$ python countdown.py"Geben Sie ein, wo der Countdown beginnen soll: 3321Start!$Kontrollieren Sie, ob die Eingabe des Benutzers grösser als Null ist. Falls nicht, geben Sie eine Fehlermeldung aus. Ein Beispiel für die Eingabe einer negativen Zahl:$ python countdown.py"Geben Sie ein, wo der Countdown beginnen soll: -3Eingabe einer Zahl grösser als 0 ist erforderlich!$2) Kopieren Sie Ihr Programm zinseszins1.py aus den Übungen in Kapitel 5.8 und nennen Sie die Kopie zinseszins2.py. Bauen Sie das Programm so um, dass es den aufgelaufenen Kapitalbetrag nach jedem Jahr der Laufzeit ausgibt:$ python zinseszins2.py"Kapitalbetrag nach Verzinsung über eine Anzahl JahreAnfangskapital: 10000Zinssatz in %: 5Anzahl Jahre: 4Kapital nach Jahr 1 10500.0Kapital nach Jahr 2 11025.0Kapital nach Jahr 3 11576.250000000002Kapital nach Jahr 4 12155.062500000002$3) Entwerfen, programmieren und testen Sie das Programm beersong1.py. Leiten Sie die Funktionsweise aus dem folgenden Beispiel ab, in dem beersong1.py mit der Eingabe 4 ausgeführt wird: $ python beersong1.pyDer Kühlschrank ist leer.Wie viele Flaschen Bier kaufen? 44 Flaschen Bier im Kühlschrank4 Flaschen BierNimm Eine rausTrink Sie aus3 Flaschen Bier im Kühlschrank3 Flaschen BierNimm Eine rausTrink Sie aus2 Flaschen Bier im Kühlschrank2 Flaschen BierNimm Eine rausTrink Sie aus1 Flasche Bier im Kühlschrank1 Flasche BierNimm Eine rausTrink Sie ausDer Kühlschrank ist leer ...Testen Sie das Programm mit verschiedenen Eingabewerten (Bei „Wie viele Flaschen Bier kaufen?“). Beachten Sie, wie sich die Ausgabe bei der letzten Flasche geringfügig verändert! Schreiben Sie sich zunächst wieder einen Entwurf als Skizze auf, bevor Sie mit dem Programmieren beginnen.4) Schreiben sie ein Programm papagei.py, das in einer Endlos-Schleife eine Eingabe abfragt und die Eingabe dann einfach wieder ausgibt. Die Schleife soll enden, wenn der Benutzer die Worte «Ende» oder «Schluss» eingibt. Dann soll das Programm sich höflich verabschieden:$ python papagei.pyErzähl mir was: HalloHalloErzähl mir was: Wer bist Du?Wer bist Du?Erzähl mir was: Wiederholst Du alles, was ich schreibe?Wiederholst Du alles, was ich schreibe?Erzähl mir was: SchlussWar schön mit Dir zu reden!$Tipp: Eine Endlos-Schleife können Sie einfach mit while True: erzeugen while True :     Anweisung1    Anweisung2    usw …5) Schreiben Sie ein Programm kleines1x1.py, das für eine eingegebene Zahl das kleine Einmaleins ausgibt, zum Beispiel für die Zahl 4:Geben Sie die Zahl ein: 4Kleines 1 x 41 x 4 = 42 x 4 = 83 x 4 = 124 x 4 = 165 x 4 = 206 x 4 = 247 x 4 = 288 x 4 = 329 x 4 = 3610 x 4 = 40Auch hier können sie eine Überprüfung einbauen, die verhindert, dass die 0 oder Zahlen < 1 eingegeben werden.6) Die Fakultät einer Zahl ist in der Mathematik eine Funktion, die einer ganzen Zahl das Produkt aller natürlichen Zahlen beginnend bei 1 bis zu dieser Zahl zuordnet. Sie wird durch das Ausrufezeichen nach der Zahl symbolisiert. Ein Beispiel dafür ist: 4! = 1 * 2 * 3 * 4 = 24Schreiben Sie ein Programm falkultaet.py, das als Eingabe eine ganze Zahl bekommt und die Fakultät dieser Zahl ausgibt. Beispiel:$ python fakultaet.pyZahl: 44! = 248 Die StandardbibliothekZusätzlich zu den in Python eingebauten Funktionen, die sie in Kapitel 5 kennengelernt haben gibt es eine Sehr grosse Anzahl weiterer nützlicher Objekte und Funktionen, die sie benutzen können. Sie sind in Modulen zusammengefasst und alle Module zusammen bilden die Standardbibliothek.Einige Funktionen aus ausgewählten Modulen werden Sie in den nächsten Abschnitten dieses kapitels und in späteren Kapiteln kennenlernen. Die offizielle Dokumentation der Standardbibliothek finden Sie unter dem folgenden URL:https://docs.python.org/3/library/index.htmlDie Dokumentation ist in Englisch verfasst. Die Beschreibung einer kleinen Auswahl von Funktionen in deutscher Sprache finden Sie in der übersetzten Version des offiziellen «Python Tutorial» unter dem URL:https://py-tutorial-de.readthedocs.io/de/latest/stdlib.html8.1 LernzieleNach der Bearbeitung dieses Kapitels können Sie:• Module der Standardbibliothek in Ihre Programme importieren• Nützliche Funktionen aus den Modulen in Ihren Programmen verwenden8.2 Funktionen aus Modulen benutzenDie eingebauten Funktionen wie input() , int() oder print() konnten Sie bisher einfach in der REPL oder in Ihrem Programmcode benutzen. Wenn Sie darüber hinaus die vielen Funktionen aus der Standardbibliothek benutzen wollen, müssen Sie zunächst die Funktionen importieren. Dies erfolgt mit dem Schlüsselwort import. Nehmen Sie an, Sie wollen Quadratwurzeln berechnen, und die Cosinus-Funktion und die Zahl Pi benutzen.  Das folgende Beispiel zeigt dies an der Funktion sqrt(zahl), die die Quadratwurzel des in den Klammern übergebenen Werts zurückgibt. Sie befindet sich im Modul math:>>> from math import sqrt>>> sqrt(16)4.0>>>Zunächst wird die Funktion sqrt() in den sogenannten Namensraum ihrer REPL-Sitzung oder ihres Python-Programms importiert. Dies geschieht in der Form: from modulname import funktionsname. Erst dann ist die Funktion bekannt und kann benutzt werden.Alternativ dazu kann auch das ganze Modul math importiert werden. Dies erfolgt in der Form: import modulname Danach können die Funktionen in diesem Modul in der Form modulname.funktion()  benutzt werden ():>>> import math>>> math.cos(1)0.5403023058681398>>>
Das Modul math enthält neben Funktionen auch Konstanten wie die Zahl Pi:>>> math.pi3.141592653589793>>>>>> math.cos(math.pi)-1.0>>>8.3 Module, Funktionen und das import-SystemDas folgende Bild zeigt den Zusammenhang zwischen einer Funktion, dem Modul aus der sie stammt und der Standardbibliothek:Abbildung 81 Funktion, Modul und StandardbibliothekUm ein ein einzelnes Objekt oder eine einzelne Funktion zu importieren, verwenden Siefrom modulname import objektameUm alle Objekte und Funktionen eines Moduls zu importieren, verwenden Siefrom modulname import *Auf diese beiden Weisen importierte Objekte (Funktionen) können anschliessend in Ihrem Programm mit objektname angesprochen werden.Um das gesamte Modul zu importieren, verwenden Sieimport modulnameWenn Sie anschliessend Objekte (Funktionen) aus diesem Modul in Ihrem Programm verwenden wollen, sprechen Sie diese mit modulname.objektname an.Um mehrere Module in einer Zeile zu importieren, verwenden Sieimport modulname1, modulname2, …Sie können beim Import auch Aliasnamen für Module und Objekte (Funktionen) vergeben und diese anschliessend anstelle der eigentlichen Namen verwenden:>>> import math as m>>> m.sqrt(16)4.0>>> from math import sqrt as qudratwurzel>>> qudratwurzel(16)4.0>>>Im Editor von Visual Studio Code erhalten Sie bei der Eingabe von Namen aus dem importierten Modul Vorschläge, die Sie übernehmen können:8.4 Weitere Beispiele aus der StandardbibliothekIn diesem Abschnitt finden Sie einige Beispiele für die Verwendung von Funktionen aus der Standardbibliothek. Das erste Beispiel zeigt die Verwendung des Objekts datetime.date.today() aus dem Modul datetime:>>> from datetime import date>>> date.today()datetime.date(2019, 4, 25)>>> date.isoformat(date.today())'2019-04-25'>>> date.today().day25>>> date.today().month4>>> date.today().year2019Das Objekt datetime.datetime.today() liefert zusätzlich Informationen zur Uhrzeit>>> from datetime import datetime>>> datetime.today().hour16>>> datetime.today().minute24Das Modul time enthält eine Funktion sleep(), die für die angegebene Zeit in Sekunden wartet. Probieren Sie das in der REPL aus:>>> import time>>> time.sleep(5)>>>Es dauert fünf Sekunden, bis der Prompt wieder erscheint.Die Funktion randint() aus dem Modul random liefert Zufallszahlen zwischen zwei Werten. Im folgenden Beispiel werden zufällige Werte zwischen 1 und 49 erzeugt:>>> from random import randint>>> randint(1,49)28>>> randint(1,49)46>>> randint(1,49)27Alle Inhalte eines Moduls können Sie nach erfolgtem Import des Moduls random mit der Funktion dir auflisten:>>> dir(random)['BPF', 'LOG4', 'NV_MAGICCONST', 'RECIP_BPF', 'Random', 'SG_MAGICCONST', 'SystemRandom', 'TWOPI', '_BuiltinMethodType', '_MethodType', '_Sequence', '_Set', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_acos', '_bisect', '_ceil', '_cos', '_e', '_exp', '_inst', '_itertools', '_log', '_os', '_pi', '_random', '_sha512', '_sin', '_sqrt', '_test', '_test_generator', '_urandom', '_warn', 'betavariate', 'choice', 'choices', 'expovariate', 'gammavariate', 'gauss', 'getrandbits', 'getstate', 'lognormvariate', 'normalvariate', 'paretovariate', 'randint', 'random', 'randrange', 'sample', 'seed', 'setstate', 'shuffle', 'triangular', 'uniform', 'vonmisesvariate', 'weibullvariate']>>>Hilfe zur Funktion randint erhalten Sie mit;>>> help(random.randint)Help on method randint in module random:randint(a, b) method of random.Random instance    Return random integer in range [a, b], including both end points.(END)Komfortabler ist es natürlich, die online-Dokumentation der Standardbibliothek zu lesen. Sie finden Sie unter diesem URL:https://docs.python.org/3/library/index.html8.5 Zusammenfassung• Zu Python gehört eine umfangreiche Standardbibliothek, die Ihnen das Programmieren von Funktionen für viele Standardaufgaben abnimmt.• Die Standardbibliothek ist in verschiedene Module aufgeteilt, die jeweils Funktionen oder Objekte aus einem bestimmten Anwendungsbereich enthalten.• Jedes Modul enthält Objekte und Funktionen, die Sie in Ihre eigenen Programme importieren und dort benutzen können• Ganze Module können mit import modulname importiert werden. Dann müssen Objekte bzw. Funktionen aus dem Modul mit der Schreibweise modulname.objektname bzw. modulname.funktionsname benutzt werden• Mit from modulname import objektname können Sie auch gezielt einzelne Objekte importieren. Dann können Sie die importierten Objekte ohne den vorangestellten Modulnamen verwenden.
8.6 Aufgaben1) Schreiben Sie ein Programm what_time.py, das die aktuelle Uhrzeit (Stunde und Minute) mithilfe des Moduls datetime abfragt. Je nachdem, wie viele Minuten es ermittelt und welche Tageszeit es ist, gibt es die Uhrzeit in unterschiedlicher Form aus:Um 10:10 vormittags:$ python what_time.py10 nach 10$Um 12:30:$ python what_timeHalb 1$Um 12:40:$ python what_time20 vor 12$Um 19:55:$ python what_time5 vor 8$2) Schreiben Sie ein Programm sekunden.py, dass in einer Schleife die Sekunden aus den Objekt datetime.datetime.today().second ermittelt und prüft, ob die Sekunde eine gerade oder ungerade Sekunde ist. Dann wartet das Programm drei Sekunden, bevor es die nächste Zeitabfrage macht. Das Ganze soll fünfmal wiederholt werden. Ein Beispiel:$ python sekunden.py26 ist eine gerade Sekunde29 ist eine ungerade Sekunde32 ist eine gerade Sekunde35 ist eine ungerade Sekunde38 ist eine gerade Sekunde3) Modifizieren Sie sekunden.py so, dass die Wartezeit zwischen zwei Zeitmessungen zufällig zwischen einer und drei Sekunden schwankt. 9 ListenBisher haben Sie mit Variablen und Werten der Datentypen wie int, float und str gearbeitet, denen Sie jeweils einen Wert zugewiesen haben.Darüber hinaus bietet Python auch Datentypen an, die mehrere Werte speichern können. Diese Werden Sequenztypen genannt. Ein Beispiel dafür ist die Liste, der wahrscheinlich am häufigsten verwendete Sequenztyp.9.1 LernzieleNach der Bearbeitung dieses Kapitels können Sie• Listen auf verschiedene Weisen erzeugen• Werte bzw. Objekte zu Listen hinzufügen• Auf einzelne Elemente einer Liste über den Index zugreifen• Elemente aus einer Liste entfernen• Die Länge einer Liste bestimmen9.2 Eigenschaften von ListenEine Liste enthält beliebig viele Objekte als Elemente. Während eine int-, float- oder str-Variable nur auf ein einzelnes Objekt verweist und genau einen Wert speichert, kann eine Liste auf eine Folge von beliebig vielen Objekten verweisen. Wichtige Eigenschaften einer Liste sind:• Die Objekte in einer Liste können alle vom gleichen Typ oder von verschiedenartigen Typen sein. • Listen sind dynamisch, d.h. sie können zur Laufzeit wachsen oder Schrumpfen• Die Elemente haben eine Reihenfolge, sie sind (beginnend mit 0) durchnummeriertEin Liste in Python entspricht in etwa einem Array in anderen Programmiersprachen wie z.B. in C#, Java oder der bash-Shell in Linux.9.3 Listen erzeugenEine Liste ist kann mit Literalen als Elemente erzeugt werden. Je nach Art des Literals (eine Zahl oder ein String im folgenden Beispiel) wird ein passendes Objekt erzeugt. Dabei werden die Elemente durch Kommas getrennt innerhalb der eckigen Klammern angegeben. >>> liste1 = [ 1, 2, 3, 'vier', 5 ]>>> liste1[1, 2, 3, 'vier', 5]>>>Sie sehen an diesem Beispiel, dass die Liste liste1 Objekte verschiedenen Typs speichert: Während vier der Elemente ganze Zahlen sind, ist eines der Elemente eine Zeichenkette. In Listen können Objekte mit beliebigen Datentypen gemischt vorkommen. Eine Liste kann auch zunächst leer angelegt und dann schrittweise durch append() gefüllt werden:>>> liste2 = []>>> liste2[]>>> liste2.append(6)>>> liste2[6]>>> liste2.append(7)>>> liste2[6, 7]>>> liste2.append("acht")>>> liste2[6, 7, 'acht']Das hierbenutzte liste2.append() ist eine sogenannte Listen-Methode. Eine Methode hat wie eine Funktion allfällige Parameter, die Sie als Input erhält und entweder einen verwendbaren Wert oder „None“ als Rückgabewert. Die Methode list.append() hat den Rückgabewert „None“9.4 Anzahl Elemente einer ListeIn der Standardbibliothek von Python ist die Funktion len() enthalten. Die Funktion akzeptiert beispielsweise eine Listen-Variable als Argument gibt die Anzahl der Elemente als Wert zurück. >>> len(liste1)5>>> len(liste2)3Die Funktion len() kann auch auf einen String angewendet werden:>>> text1 = 'Höhere Fachschule'>>> len(text1)17Der Rückgabewert einer Funktion kann einer Variablen zugewiesen werden:>>> laenge = len(text1)>>> laenge179.5 Listenelemente und ihr IndexAuf Listenelemente kann über ihren Index lesend und schreibend zugegriffen werden. Der aufsteigende Index beginnt bei 0 für das erste Element. Zusätzlich gibt es einen absteigenden Index. Dieser bietet mit  -1 Zugriff auf das letzte Element, mit -2 auf das vorletzte.Aufsteigender IndexMit der Schreibweise Liste[ Index ] kann auf jedes Element zugegriffen werden. Die folgende Abbildung zeigt die Liste liste1:Abbildung 91 Aufsteigender Index>>> liste1[1, 2, 3, 'vier', 5]>>> liste1[0]1>>> liste1[3]'vier'>>> liste1[3] = 4Nach dieser Anweisung sieht liste1 so aus:Abbildung 92>>> liste1[1, 2, 3, 4, 5]Probieren Sie aus, auf einen Index über 5 zuzugreifen. Dies erzeugt einen IndexError.
Absteigender IndexJede Liste hat zusätzlich einen absteigenden Index, der beim letzten Element mit -1 beginnt und  mit dem 1. Element endetAbbildung 93 Absteigender Index>>> liste1 = [ 1, 2, 3, 4, 5 ]>>> liste1[1, 2, 3, 4, 5]>>> liste1[ -1 ]5>>> liste1[ -3 ]3>>> liste1[ -5 ]1Vorhandensein eines Elements in einer ListeMit dem logischen Operator in können Sie überprüfen, ob eine Liste einen bestimmten Wert enthält. Probieren Sie das an verschiedenen Beispielen aus. Denken Sie daran, dass Sie für Zeichenketten Anführungszeichen verwenden müssen.>>> zahlen = [ 13, 5, 22 ]>>> moebel = [ 'Stuhl', 'Tisch', 'Schrank' ]>>> 5 in zahlenTrue>>> 1 in zahlenFalse>>> 'Stuhl' in moebelTrue>>> 'Bett' in moebelFalse>>>Die folgenden Beispiele zeigen die Verwendung von not in. Mit not wird ein beliebiger logischer Ausdruck verneint, d.h. True wird zu False und False wird zu True>>> 13 not in zahlenFalse>>> 100 not in zahlenTrue>>> 'Bett' not in moebelTrue9.6 Listen-Objekte kopierenWas passiert, wenn eine Listen-Variable eine andere Listen-Variable zugewiesen bekommt? Machen Sie folgendes Experiment:>>> liste3 = [1, 2, 3, 4, 5]>>> liste3 = liste1>>> liste1[1, 2, 3, 4, 5]>>> liste3[1, 2, 3, 4, 5]Beide Ausgaben zeigen den gleichen Inhalt für liste1 und liste2. Bedeutet das, dass Sie liste1 kopiert haben?  Probieren Sie das aus, indem Sie den Inhalt von liste1 verändern:>>> liste1.append(6)>>> liste1[1, 2, 3, 4, 5, 6]>>> liste3[1, 2, 3, 4, 5, 6]Offenbar wurde keine Kopie erzeugt, denn die Änderung an liste1 hat sich auch auf den Inhalt von liste3 ausgewirkt. Erinnern Sie sich an die Diskussion von Variablen und Objekten aus Kapitel 3.7? Dort haben Sie erfahren, dass Variablen nur Verweise auf Objekte im Hauptspeicher sind. Unser Listen-Beispiel stellt sich vor diesem Hintergrund so dar:Abbildung 94 Listen-Variablen und -Objekte nach Zuweisung (1) und Änderung (2)Listen kopieren mit copy()Listen-Variablen und Listen-Objekte verhalten sich also etwas anders als einfache Datentypen. Wenn die Variable liste3 auf eine unabhängige Kopie von liste1 verweisen soll, muss man die Listen-Methode copy() verwenden. Liste.copy() erzeugt eine exakte Kopie des Listen-Objekts mit allen Elementen und gibt eine Referenz darauf zurück.>>> liste1 = [ 1, 2, 3, 5 ]>>> liste3 = liste1.copy()>>> liste3[1, 2, 3, 5]>>> liste1.append(6)>>> liste1[1, 2, 3, 5, 6]>>> liste3[1, 2, 3, 5]Abbildung 95 Die Wirkung der Listen-Methode copy()Die Variable liste3 zeigt nach (1) auf eine Kopie des Listen-Objekts und die Änderung an liste1 in Schritt (2) beeinflusst diese Kopie nicht. Während append() ein neues Element am Ende der Liste anfügt, kann mit insert() ein Element an einer beliebigen Position einer Liste eingefügt werden:Die Methode liste.insert( index, wert ) fügt ein neues Element wert vor der Stelle ein, die mit index festgelegt wird. Denken Sie daran, dass der index bei 0 beginnt:>>> food = [ 'Brot', 'Käse', 'Obst' ]>>> food.insert(1,'Müsli')>>> food['Brot', 'Müsli', 'Käse', 'Obst']Elemente entfernen Es gibt mehere Wege, ein Element aus einer Liste zu entfernen:• Mit del liste[index]• Mit liste.pop(index)• Mit liste.remove(wert)Mit del liste[index] wird das Element an der Position index gelöscht>>> liste = [1, 2, 3]>>> del liste[1]>>> liste[1, 3]Mit liste.pop( index ) wird ein Element an der Position index entfernt. Der Wert des entfernten Elements wird dabei zurückgegeben und kann einer Variablen zugewiesen werden:>>> food['Brot', 'Käse', 'Obst', 'Müsli']>>> entfernt = food.pop(1)>>> food['Brot', 'Obst', 'Müsli']>>> entfernt'Käse'Wird index nicht angegeben, entfernt pop() das letzte Element aus der Liste und gibt dessen Wert zurück:>>> food['Brot', 'Obst', 'Müsli']>>> entfernt=food.pop()>>> food['Brot', 'Obst']>>> entfernt'Müsli'Mit liste.remove( wert ) kann das erste Vorkommen von wert aus der Liste entfernt werden. Ein Beispiel:['Brot', 'Müsli', 'Käse', 'Obst', 'Müsli']>>> food.remove('Müsli')>>> food['Brot', 'Käse', 'Obst', 'Müsli']Listen sortierenMit list.sort() werden die Elemente einer Liste sortiert. Nach dem Aufruf haben die Elemente der Liste eine neue, aufsteigend sortierte Reihenfolge:>>> liste = [ 1, 9, 3, 11, 5 ]>>> liste.sort()>>> liste[1, 3, 5, 9, 11]Sortierte Listen aus Listen erzeugenWährend list.sort() die Reihenfolge der Elemente dauerhaft verändert, erzeugt die Funktion sorted(liste) eine aufsteigend sortierte Kopie der Liste. Die ursprüngliche Liste bleibt unverändert.>>> liste1 = [1, 9, 3, 11, 5]>>> liste2 = sorted(liste1)>>> liste2[1, 3, 5, 9, 11]>>> liste1[1, 9, 3, 11, 5]Weitere Listen-MethodenSchlagen Sie in der Referenzdokumentation die Informationen zu weiteren Listenmethoden nach:list.clear()list.count( wert )list.index( wert, start, stop )list.reverse()Sie finden die Dokumentation dieser Methoden unter:https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range9.7 Teile von Listen verwendenSie können auch Teilbereiche von Listen verwenden. Ein Teil einer Liste wird in Python Slice genannt. Die Schreibweise für eine Slice ist:Liste[start:stop]Der Zahlenwert start ist der Index des ersten Elements des Teils der Liste, der verwendet werden soll. Der Wert stop ist der Index des Elements, das nicht mehr zum Teilbereich gehört. Das folgende Beispiel zeigt die Verwendung:>>> liste = [101, 233, 1803, 789, 95]>>> liste[2:3][1803]>>> liste[2:4][1803, 789]>>> liste[1:4][233, 1803, 789]Wird stop weggelassen, beginnt der Teilbereich beim Index start und endet beim letzten Element der Liste:>>> liste[3:][789, 95]Wird start weggelassen, beginnt der Teilbereich beim Index 0 und endet beim Index stop-1>>> liste[:3][101, 233, 1803]Die Slice-Schreibweise erzeugt eine neue Liste als unabhängiges Objekt. Dies kann einer neuen Variablen zugewiesen werden:>>> liste_neu=liste[2:4]>>> liste_neu[1803, 789]>>> liste[2] = 1000>>> liste_neu[1803, 789]Die Slice liste[:] ergibt die gesamte Liste:>>> liste1 = [ 1, 2, 3, 4 ]>>> liste2 = liste1[:]>>> liste2 [1, 2, 3, 4]Sie können Slices auch auf der linken Seite von Zuweisungen verwenden. Im folgenden Beispiel werden Die beiden Elemente mit dem Index 1 und 2 durch neue Werte ersetzt. Beachten Sie, dass auf der rechten Seite des Gleichheitszeichens eine Liste steht:[101, 233, 1000, 789, 95]>>> liste[1:3] = [100, 300]>>> liste[101, 100, 300, 789, 95]9.8 Zusammenfassung Mit Listen haben Sie eine der wichtigsten Datenstrukturen kennengelernt. Die wichtigsten Fakten zu listen sind:• Eine Liste enthält beliebig viele Objekte als Elemente. Die Elemente können unterschiedliche Datentypen haben.• Die Reihenfolge der Elemente in einer Liste ist festgelegt. Die Position jedes Elements wird durch einen Index festgelegt. Dieser beginnt mit 0 und kann in eckigen Klammern nach dem Namen der Liste angegeben werden. Auf das erste Element einer Liste kann mit liste[0] zugegriffen werden, auf das zweite mit liste[1], auf das letzte mit liste[-1]• Eine Liste kann aus Literalen erzeugt werden, die innerhalb von eckigen klammern durch Kommas getrennt angegeben werden, z.B. liste = [ ‘ja’, ‘nein’, ‘unentschieden’]• In den eckigen Klammern können ausser Literalen auch Variablen und Funktionen, die eine Wert zurückgeben stehen.• Eine leere liste kann mit liste = [] angelegt werden.• An das Ende einer Liste kann mit liste.append(Element) jederzeit ein Element angehängt werden• Mit dem logischen Operator in kann geprüft werden, ob sich ein bestimmter Wert in einer Liste befindet. Die umgekehrte Prüfung kann mit not in erfolgen• Mit der Funktion len(liste) kann die Anzahl der Elemente einer Liste ermittelt werden• Mit del liste[index] wird das Element an der Position index gelöscht• Listen sind Objekte und haben Methoden, mit denen Sie verändert werden können. Sie werden ähnlich wie Funktionen, aber mit der Punktschreibweise aufgerufen, z.B.o Liste.append( Objekt ) – Anhängen eines Objekts an die Listeo Liste.insert( Index, Objekt ) – Einfügen an der Stelle Indexo Liste.remove( Wert ) – Entfernen des ersten Vorkommens von Werto Liste.pop( Index ) – Entfernen des Elements am Index mit Wert-Rückgabeo Liste.copy() – Kopie der Liste erzeugeno Liste.sort() – Die Elemente der Liste dauerhaft sortieren• Die Funktion sorted(Liste) gibt eine sortierte Kopie der Liste zurück, ohne die ursprüngliche Liste zu verändern• Teilbereiche von Listen heissen in Python Slices. Slices werden durch die Schreibweise liste[start_index:stop_index] erzeugt. Die Slice liste[:] erzeugt eine komplette Kopie der Liste.9.9 Aufgaben1) Im Programm eintritt3.py in Kapitel 6 wurden zwei Bedingungen überprüft und mit or verknüpft.if antwort == 'J' or antwort == 'j':ist_student = TrueWie könnte das mithilfe einer Liste gelöst werden, die verschiedene denkbare Antworten (z.B. ‘J’, ‘j’, ‘Ja’, ‘ja’, ‘JA’, ‘Yep’, ‘Aber sicher’, ‘Jawohl’ oder ‘Klar, Mann’) enthält?2) Programmieren Sie das Programm namen.py mit einer Abfrage von Namen in einer while-Schleife, in der der Benutzer pro Durchlauf einen Namen angeben kann. Dieser Name wird dann der Liste hinzugefügt. Die Eingabe soll enden, wenn der Benutzer «ENDE» eingibt. Sortieren Sie dann die Liste alphabetisch und geben Sie sie aus. Ein Beispiel:$ python namen.pyGeben Sie einen Namen ein. Abschluss mit ENDE: MoeGeben Sie einen Namen ein. Abschluss mit ENDE: LarryGeben Sie einen Namen ein. Abschluss mit ENDE: CurlyGeben Sie einen Namen ein. Abschluss mit ENDE: ENDE['Curly', 'Larry', 'Moe']$3) Erweitern Sie das Programm namen.py so, dass Sie nach der Eingabe der Namen und den obigen Ausgaben in einer weiteren Schleife den Index eines der Namen eingeben können. Daraufhin soll der entsprechende Name ausgegeben werden. Indizes im obigen Beispiel beginnen bei 0 und enden bei 2. Eine Eingabe einer Zahl über dem höchsten belegten Index beendet das Programm. Da der höchste Index von der Anzahl der Namen in der Liste abhängt, ermitteln Sie dazu vorher die Anzahl Namen in der Liste:Welcher Index?. Abschluss mit einer Zahl > 2: 0CurlyWelcher Index?. Abschluss mit einer Zahl > 2: 1LarryWelcher Index?. Abschluss mit einer Zahl > 2: 99$10 Die for-Schleife und SequenzenListen gehören in Python zu den sogenannten Sequenztypen. Es gibt aber auch Sequenzen, die temporär zur Laufzeit erzeugt werden. In diesem Kapitel lernen Sie mit range() eine Funktion zur Erzeugung von Sequenzen kennen. Damit können Zahlenfolgen erzeugt werden und solche Folgen können Sie mit einer weiteren Schleifenart, der for-Schleife, sehr bequem durchlaufen.10.1 LernzieleNach der Bearbeitung dieses Kapitels können Sie• Einfache Zahlenfolgen mit range(stopwert) erzeugen• Spezielle Zahlenfolgen mit range(startwert, stopwert, schrittweite) erzeugen• Schleifen mit for programmieren• Die for-Schleife mit range() kombinieren10.2 Einfache Verwendung von range()Mit range() kann ein Reihe von Zahlen erzeugt werden. Der einfachste Aufruf ist range(stopwert), wobei das Argument stopwert eine ganze Zahl sein muss: >>> folge = range(10)>>> folgerange(0, 10)Das Ergebnis von range(10) ist eine Zahlenfolge von 0 bis 9. Sichtbar wird das erst, wenn das Ergebnis mit list() in eine Liste umgewandelt wird:>>> list(folge)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]>>> list( range(3) )[0, 1, 2]10.3 Die for-SchleifeDie for-Schleife wird verwendet, um Aufzählungen zu durchlaufen. Die generelle Struktur einer for-Schleife ist:Abbildung 101 Struktur der for-schleifeDie Schleife durchläuft nacheinander alle Elemente der Aufzählung. Der jeweilige Wert des aktuellen Elements wird der Variablen zugewiesen. Für jeden Wert in der Aufzählung werden die Anweisungen in der Suite nach dem Doppelpunkt einmal ausgeführt. Ein Beispiel zeigt die Verwendung von for mit einer Aufzählung von Werten, die durch Kommas getrennt hinter dem Schlüsselwort in aufgeführt werden.  1 # for_demo.py zeigt die Anwendung von for auf eine Aufzählung 2 zaehler = 1 3 for wert in 1, 2, 3 : 4     print("Der Wert des Elements Nummer", zaehler, "ist", wert) 5     zaehler = zaehler + 1$ python for_demo.pyDer Wert des Elements Nummer 1 ist 1Der Wert des Elements Nummer 2 ist 2Der Wert des Elements Nummer 2 ist 2$Da range() eine Aufzählung von ganzen Zahlen erzeugt, kann for gut mit range(stopwert) kombiniert werden: 1  # count0to2.py demonstriert die for-Schleife mit range() 2  for zahl in range(3): 3     print(zahl)Die Ausgabe ist:$ python count0to2.py012$Sie sehen, dass hier, ähnlich wie bei einem Liste-Index, die Zählung bei 0 statt bei 1 beginnt und der stopwert 3 nicht ausgegeben wird. Als Argument von range(stopwert) kann natürlich auch eine Variable vom Typ int angegeben werden: 1  stop = int( input('stopwert: ') ) 2  for zahl in range(stop): 3      print(zahl)10.4 Verwendung von start, stop und stepWenn ein Zahlenbereich verwendet werden soll, der nicht bei 0 beginnt, kann ein anderer Startwert angegeben werden. Erzeugen Sie das folgende Programm start_stop.py : 1  # start_stop.py 2  start = int( input('startwert: ') ) 3  stop = int( input('stopwert: ') ) 4  for zahl in range(start, stop): 5      print(zahl)Testen Sie das Programm mit folgenden Eingaben:StartwertStopwert510105Was passiert in diesen beiden Fällen? Testen Sie start_stop.py auch mit anderen ganzzahligen Eingaben!Wird ein drittes ganzzahliges Argument mit einem Wert ungleich 1 angegeben, wird die Zahl nicht um 1 erhöht, sondern um die angegebene Schrittweite Das folgende Beispiel demonstriert das: 1  # schrittweite.py demonstriert die Benutzung von  2  # range(startwert, stopwert, schrittweite) 3  for zahl in range(3, 9, 2 ): 4      print(zahl)$ python schrittweite.py357$ Die erzeugte Zahlenfolge beginnt mit dem startwert 3, wird dann mit Zahlen, die jeweils um den Wert 2 grösser sind fortgesetzt und endet mit der Zahl, die sich ergibt, bevor der Stopwert erreicht oder überschritten würde. Erzeugen Sie nun das folgende Programm start_stop_step.py als Erweiterung des Programms start_stop.py: 1  # start_stop_step.py 2  start = int( input('startwert: ') ) 3  stop = int( input('stopwert: ') ) 4  step = int( input('schrittweite: ') ) 5  for zahl in range(start, stop, step): 6      print(zahl)Testen Sie das Programm mit den folgenden Eingaben, bevor Sie weiterlesen:StartwertStopwertSchrittweite101001050-180-38-3-3Probieren Sie auch weitere Eingaben aus! Was passiert?10.5 Die for-Schleife mit Aufzählungen anderer DatentypenDie Datentypen der Elemente in der Aufzählung bei for müssen nicht ganze Zahlen sein, wie das folgende Beispiel zeigt:  1  zaehler = 1 2  for wert in 'ja', 'nein', 'vielleicht' : 3      print("Element Nr.:", zaehler, "Wert:", wert) 4      zaehler = zaehler +1Die Elemente können sogar verschiedene Datentypen haben: 1  zaehler = 1 2  for wert in 'ja', 1, 7.25 : 3      print("Element Nr.:", zaehler, "Wert:", wert, "Typ:", type(wert)) 4      zaehler = zaehler +1Probieren Sie beide Beispiele aus! Was sind die Ergebnisse?10.6 for und ListenMit einer for-Schleife können Sie hervorragend die Elemente einer Liste durchlaufen. Geben Sie das Programm for_liste.py ein und führen Sie es aus: 1  # for_liste.py demonstriert das Durchlaufen einer Liste mit for 2  liste = ['ja', 'nein', 'vielleicht'] 3  for element in liste: 4      print(element)Das ginge im Prinzip auch mit einer While-Schleife. Allerdings hätten Sie dann einigen Zusatzaufwand. Zunächst müssten Sie eine Zähler-Variable mit dem Wert 0 belegen, dann mit len(liste) ermitteln wieviele Elemete die hat, dann die while-Schleife solange ausführen, wie der Zähler kleiner der Länge der Liste und sie dürfen nicht vergessen, den Zähler für jeden Schleifendurchlauf um 1 zu erhöhen (Probieren Sie das als Zusatzaufgabe aus). Die for-Schleife beendet sich dagegen automatisch, sobald das Ende der Liste erreicht ist.10.7 for und StringsBetrachten Sie das Programm for_string.py und seine Ausgabe: 1  string = ‘Hallo’ 2  for buchstabe in string: 3      print(buchstabe)$ python for_string.pyHalloDas bedeutet, das auch ein String ein Aufzählungstyp ist. Das Programm gibt die einzelnen Buchstaben im String aus. Wenn das der Fall ist, kann auch festgestellt werden, ob ein Zeichen in einem String enthalten ist:>>> string =  'lachen'>>> 'c' in stringTrue>>> 'x' in stringFalse>>>Da Python Zeichenketten wie auch einzelne Zeichen als String behandelt, funktioniert die Prüfung mit in auch mit Teilstrings:>>> 'ch' in stringTrue>>> 'tz' in stringFalse>>>Einzelne Zeichen von Strings können über ihren Index angesprochen werden:>>> ein_string = "Dampfschiffahrtsgesellschaft">>> ein_string[4]'f'Da Strings ein Aufzählungstyp ist, kann man auch Slices von Strings verwenden, indem man hinter dem String die eckigen Klammern mit [start_index:end_index+1] verwendet:>>> ein_string[0:5]'Dampf'Über eine Slice kann auch mit einer for-Schleife iteriert werden:>>> ein_string = "Dampfschiffahrtsgesellschaft">>> for c in ein_string[5:11] :...     print(c)... schiff10.8 Iterable Objekte und DatentypenHinter for in kann ein beliebiges iterierbares Objekt (iterable) stehen. Die Objekte von drei Datentypen, die Sie bisher kennengelernt haben, sind iterable: Listen, Ranges und Strings. Weitere iterable Objekte wie Tupel und Dictionaries werden Sie in Kapitel 14 kennenlernen. Wenn Sie das jetzt schon brauchen sollten, können Sie nach der Bearbeitung dieses Kapitels einen kurzen Abstecher dorthin machen.10.9 Erweiterung von for break, continue und elseWie in while-Schleifen können die Anweisungen break und continue auch in for-Schleifen verwendet werden. Mit break wird die Schleife abgebrochen, continue springt zum Schleifenkopf zurück und Anweisungen hinter else werden nur dann ausgeführt, wenn in der Schleife kein break ausgeführt wird. Versuchen Sie, die entsprechenden Beispiele aus Kapitel 7.3 auf for-Schleifen zu übertragen.10.10 ZusammenfassungZum Thema Sequenzen mit range()• Folgen von ganzen Zahlen können mit range in drei Formen erzeugt werden: - range(stop), - range(start, stop) und - range(start, stop, step) • In der Form range(stop) startet die Zahlenfolge bei 0 und hört bei stop – 1 auf.• Sie können bei der Form range(start, stop) einem beliebigen ganzzahligen Startwert beginnen. • Sie können bei einem beliebigen Stopwert enden. Der Stopwert muss als zweites Argument bei range(start, stop) angegeben werden.• Die Zahlenfolge ist aufsteigend, wenn bei range(start, stop) start kleiner als stop ist. Wenn stop kleiner als start ist, wird keine Zahlenfolge erzeugt.• Wird ein drittes Argument step bei range(start, stop, step) angegeben, bestimmt step die Schrittweite der erzeugten Zahlenfolge• Wenn bei range(start, stop, step) start grösser als stop ist und step eine negative Zahl ist, wird eine absteigenden Zahlenfolge erzeugt.• Mit list( range(start, stop, step) ) können Sie eine Liste aus ganzen Zahlen erzeugen
Zum Thema for-Schleifen• Eine for-Schleife durchläuft eine Aufzählung von Objekten. Die Variable, die direkt nach dem Schlüsselwort for steht, bekommt den Wert des jeweils aktuellen Objekts in der Aufzählung zugewiesen. Nach der Aufzählung und dem Doppelpunkt beginnt eine Suite von Anweisungen, die für jedes Element in der Aufzählung einmal ausgeführt wird. Die for-Schleife endet automatisch, wenn das Ende der Aufzählung erreicht wurde.• Die Aufzählung kann aus Literalen, getrennt durch Kommas bestehen. Diese können von verschiedenem Typ sein• Hinter for in kann auch ein iterierbares Objekt (iterable) stehen. Beispiele für iterables: Listen, Ranges und StringsZum Thema str als Aufzählungstyp• Ein String ist auch ein Aufzählungstyp• Ein String ist iterable und kann mit for durchlaufen werden• Das Vorkommen eines Zeichens oder einer Zeichenfolge kann mit in- geprüft werden. Das Gegenteil kann mit not in geprüft werden.
10.11 Aufgaben1) Erzeugen Sie eine Liste gerade_zahlen mit den geraden Zahlen von 0 bis 60 mithilfe von range()2) Erzeugen Sie eine neue Version des Programms countdown.py mit range() und einer for-Schleife statt der while-Schleife3) Erzeugen Sie eine neue Version des Programms beersong1.py als beersong2.py mit range() und einer for-Schleife statt der while-Schleife4) Erzeugen Sie Ein Programm vokale.py, das eine Liste der Vokale enthält, und für ein beliebiges eingegebenes Wort die Vokale in diesem Wort ausgibt. Beispiel:$ python vokale.pyGeben Sie ein Wort ein: Waschmaschineaaie$5) Erzeugen Sie das Programm sterne.py, das eine Zahl als Eingabe bekommt und eine entsprechende Anzahl von Sternen im Terminal ausgibt:$ python sterne.pyAnzahl Sterne: 8********Verwenden Sie dafür eine for-Schleife.6) Erzeugen Sie ein Programm dreieck.py, das das eine Zahl als Eingabe bekommt und ein rechtwinkliges Dreieck aus Sternen mit entsprechend vielen Zeilen und Spalten im Terminal ausgibt:$ python dreieck.pySeitenlänge: 8** ** * ** * * ** * * * ** * * * * ** * * * * * ** * * * * * * *Tipp: Verwenden Sie dafür nötigenfalls zwei for-Schleifen, eine für die Zeilen, eine für die Spalten der Ausgabe.7) Die Fibonacci-Folge beginnt mit zweimal der Zahl 1. Im Anschluss ergibt jeweils die Summe der beiden Zahlen davor die danach folgende Zahl. Die ersten sieben Zahlen der Folge sind: 1, 1, 2, 3, 5, 8, 13Schreiben Sie ein Programm, das die Fibonacci-Folge bis zu einer bestimmten Stelle ausgibt. Beispiel:$ python fibonacci.pyWieviele Stellen? 8112358138) In der Informatik werden häufig Primzahlen benötigt, zum Beispiel für Verschlüsselungs-Algorithmen. Eine Primzahl ist eine Zahl, die ohne Rest nur durch sich selbst oder durch die Zahl 1 teilbar ist. Wenn man Primzahlen finden möchte, muss man eine Zahl nach der anderen darauf überprüfen, ob Sie durch eine andere Zahl zwischen 2 und der Zahl/2 ohne Rest teilbar ist.Schreiben Sie ein Programm primzahlen.py, das durch Ausprobieren nach Primzahlen innerhalb eines Zahlenbereichs sucht. Es soll alle gefundenen Primzahlen ausgeben. Tipps: Schauen Sie Sich noch einmal die Operatoren für die ganzzahlige Division und den Divisionsrest in Kapitel 2.3 an. Sie benötigen möglicherweise mehrere Schleifen, um das Problem zu lösen. Ein Beispiel für die Ausführung:$ python primzahlen.pyPrimzahlen im Bereich von: 1bis: 202 3 5 7 11 13 17 19 $9) Messen Sie die Zeit, die primzahlen.py bei grösseren Zahlenbereichen (wie z.B. von 0 bis 5000, 5000 bis 10000, 10000 bis 20000, 0 bis 30000) benötigt. Dafür können Sie die Methode perf_counter() des time-Objekts verwenden:import timestartzeit = time.perf_counter()# Zwischen den beiden Zeitmessungen wird Ihr Code ausgeführtstopzeit = time.perf_counter()print('Laufzeit in Sekunden: ', stopzeit - startzeit)Erzeugen Sie eine Variante von primzahlen.py ohne Ausgabe der Primzahlen. Vergleichen Sie den Zeitbedarf dieser Variante mit dem der Variante mit Ausgabe.10) Erzeugen Sie ein Programm lotto1.py das mit random.randint() aus dem Modul random sechs Zufallszahlen zwischen 1 und 49 erzeugt. Fügen Sie diese Zahlen in eine Liste ein. Prüfen Sie vorher für jede Zahl, ob sie bereits in der Liste vorkommt, denn doppelte Lottozahlen soll es natürlich nicht geben. Diesen Teil können Sie aus der Lösung der Aufgabe lottoziehung.py im Kapitel 9.9 übernehmen.Anschliessend fordern Sie den Benutzer in einer Schleife auf, seinen Lottotipp mit sechs Zahlen einzugeben, der in einer zweiten Liste gespeichert wird. Als Hilfe zeigen Sie an, welche Zahlen schon getippt wurden,Nach der Eingabe der 6 Zahlen überprüfen Sie in einer weiteren Schleife für jede Zahl des Tipps, ob sie in der Liste der gezogenen Zahlen enthalten ist.Am Ende geben Sie die gezogenen Lottozahlen und den Tipp aufsteigend sortiert aus, und geben an, wie viele Zahlen richtig getippt wurden.Stellen Sie sicher, dass genau 6 Zahlen eingegeben werden, dass es Zahlen von 1 bis 49 sind und dass keine Zahl mehrfach erfasst wird. Ein Beispiel:$ python lotto1.pyGeben Sie Ihren Tipp ein. (6 Zahlen von 1 bis 49)Bisher eingegeben:  []Geben Sie eine neue Zahl von 1 bis 49 ein: 1Bisher eingegeben:  [1]Geben Sie eine neue Zahl von 1 bis 49 ein: 9Bisher eingegeben:  [1, 9]Geben Sie eine neue Zahl von 1 bis 49 ein: fooEingabe war keine ganze ZahlBisher eingegeben:  [1, 9]Geben Sie eine neue Zahl von 1 bis 49 ein: 13Bisher eingegeben:  [1, 9, 13]Geben Sie eine neue Zahl von 1 bis 49 ein: 19Bisher eingegeben:  [1, 9, 13, 19]Geben Sie eine neue Zahl von 1 bis 49 ein: 50Zahl schon vorhanden oder ausserhalb des BereichsBisher eingegeben:  [1, 9, 13, 19]Geben Sie eine neue Zahl von 1 bis 49 ein: 19Zahl schon vorhanden oder ausserhalb des BereichsBisher eingegeben:  [1, 9, 13, 19]Geben Sie eine neue Zahl von 1 bis 49 ein: 30Bisher eingegeben:  [1, 9, 13, 19, 30]Geben Sie eine neue Zahl von 1 bis 49 ein: 44Ziehung: [3, 24, 28, 30, 39, 40]Ihr Tipp: [1, 9, 13, 19, 30, 44]Richtige: 1 [30]]11 Mehr zu StringsAuch Strings sind Objekte und haben Methoden, die bereits für Sie definiert sind. In diesem Kapitel lernen Sie einige String-Methoden und typische Anwendungen für sie kennen.11.1 LernzieleNach dem Bearbeiten dieses Kapitels können Sie• Mehrzeilige String-Literale verwenden• Einige wichtige Eigenschaften von Strings benennen• Strings auf verschiedene Weise formatieren• Inhalte eines Strings auf bestimmte Eigenschaften überprüfen• Teile von Strings finden und bearbeiten11.2 String-Literale und -VariablenZwei verschiedene Schreibweisen für String-Literale sind ihnen bereits bekannt:'Das ist ein String-Literal'"Das auch"Solche String-Literale müssen innerhalb einer Programmzeile abgeschlossen werden. Das gilt nicht  für eine dritte Schreibweise mit drei Anführungszeichen, die Sie bereits von Kommenaren her kennen:"""Diese Form von String-Literal Kann sich auch über mehrere Zeilen erstrecken"""Wenn Sie in einem Programm oder in der REPL ein Literal verwenden, wird ein Objekt im Hauptspeicher angelegt. Wenn Sie das Literal einer Variablen zuweisen, bekommt das Objekt damit einen symbolischen Namen:>>> ein_wort = "Hey"11.3 Ein String als Aufzählung von ZeichenDer Datentyp str ist ein weiterer Aufzählungstyp wie list und range. Die einzelnen Elemente eines Strings sind sogenannte Unicode-Zeichen. Unicode ist ein internationaler Standard, in dem für die Schriftzeichen verschiedener Sprachen und Schriftkulturen und Zeichensysteme je ein digitaler Code festgelegt wird. Das die einzelnen Zeichen eines Strings ähnlich wie die Elemente einer Liste behandelt werden können, haben Sie im Kapitel 10.5 gesehen. Jedes einzelnes Zeichen eines Strings ist wieder vom Typ str:>>> ein_wort = "Hey">>> for zeichen in ein_wort:...     type(zeichen)... <class 'str'><class 'str'><class 'str'>Viele der Operationen und Funktionen, die auf Elemente von Listen angewendet werden konnten, können daher auch auf Strings angewendet werden:>>> wort = "Hey">>> string[1]'e'>>>>>> len(wort)3>>> min(wort)'H'>>> max(wort)'y'>>>Die Funktionen min() und max() betrachten dabei die Position der Zeichen im Unicode-Zeichensatz, in dem die Grossbuchstaben vor den Kleinbuchstaben stehen.Mit dem Operator in haben Sie bereits das Vorkommen eines Elements in einer Liste oder das Vorkommen eines Buchstaben in einem Wort geprüft. Als Besonderheit bei Strings kann damit auch noch das Vorkommen einen Teil-Strings im String geprüft werden:>>> ein_wort = 'Dampfschiff'>>> 'sch' in ein_wortTrue>>>11.4 Strings sind unveränderlichIm Gegensatz zu Listen sind Strings immutable (unveränderlich). Daher sind bestimmte Methoden wie append() oder sort(), mit der eine Liste verändert wird, für Strings nicht verfügbar:>>> mein_string = "Hey">>> mein_string.append(" Du")Traceback (most recent call last):  File "<stdin>", line 1, in <module>AttributeError: 'str' object has no attribute 'append'>>> mein_string.sort()Traceback (most recent call last):  File "<stdin>", line 1, in <module>AttributeError: 'str' object has no attribute 'sort'Allerdings ist folgendes problemlos möglich:>>> mein_string = mein_string + " Du">>> mein_string'Hey Du'Das steht scheinbar im Widerspruch zu der Aussage, dass Strings unveränderlich sind. Was dabei tatsachlich passiert, zeigen die folgenden Abbildungen. Zunächst erfolgt die Zuweisung eines String-Literals an die Variable mein_string:Das Objekt 1 wird erzeugt und der Name mein_string verweist auf dieses Objekt. Wenn in der zweiten Anweisung dem String scheinbar das « Du» hinzugefügt wird, legt der Python-Interpreter ein neues Objekt 2 an, das das Ergebnis der Zuweisung enthält:Die Variable mein_string verweist nun auf das neue Objekt und nicht mehr auf das bisherige Objekt.Auf das Objekt 1 aus der ersten Zuweisung kann nun nicht mehr über die Variable mein_string zugegriffen werden. Objekte, auf die keine Variable mehr verweist, belegen Speicher, sind aber nutzlos, weil sie nicht mehr im Programm verwendet werden können. Daher löscht der Python-Interpreter solche «verwaisten» Objekte automatisch und gibt den von ihnen belegten Speicher wieder frei. Der Fachbegriff dafür ist Garbage Collection. Ein grosser Vorteil von Programmiersprachen mit automatischer Garbage Collection ist, dass sich der Programmierer nicht um die Freigabe von nicht mehr genutztem Speicherplatz kümmern muss.Auch leere Strings sind Objekte. Sie können als Literal mit zwei einfachen oder doppelten Anführungszeichen geschrieben werden:>>> s1 = "">>> s1''>>> type(s1)<class 'str'>11.5 Strings formatierenFür den Datentyp str gibt es einige vordefinierte Methoden, mit denen der Inhalt von Strings auf verschiedene Arten aufbereitet werden kann. Dabei wird ein neuer, entsprechend formatierter String zurückgegeben. Die erste Gruppe von Format-Methoden beschäftigt sich mit Gross- und Kleinschreibung:str.upper()str.captialize()str.title()str.lower()str.casefold()Die folgenden Beispiele zeigen jeweils eine dieser Methoden und ihre Wirkung:>>> ein_string = "das leben des brian">>> ein_string.upper()'DAS LEBEN DES BRIAN'>>> ein_string.capitalize()'Das leben des brian'>>> ein_string.title()'Das Leben Des Brian'>>> ein_string = 'HALT! GEFAHR!'>>> ein_string.lower()'halt! gefahr!'>>> ein_string = 'Daß Du mir ja keinen Mist baust!'>>> ein_string.casefold()'dass du mir ja keinen mist baust!'Die Methode casefold() wandelt im Unterschied zu lower() auch spezielle vorhandene Kleinbuchstaben um, z.B. das deutsche ‘ß’ in ‘ss’.str.center()str.rjust()Weitere Arten der Formatierung beinhalten das Auffüllen von Strings mit Leerzeichen, um eine zentrierte ( center() ) oder rechtsbündige ( rjust() ) Formatierung zu erreichen:>>> word_list = ['Das', 'Schiff', 'der', 'Schifffahrtsgesellschaft']>>> for w in word_list:...     w.center(30,' ')... '             Das              ''            Schiff            ''             der              ''   Schifffahrtsgesellschaft   '>>> for w in word_list:...     w.rjust(30,' ')... '                           Das''                        Schiff''                           der''      Schifffahrtsgesellschaft'time.strftime()datetime.date.strftime()datetime.datetime.strftime()Eine Formatierung wird häufig für Datums-, Zeit- und Zahlenwerte benötigt. Datums- und Zeitobjekte haben Sie im Kapitel 8 kennengelernt. Um ein Datum im deutsche Format auszugeben, können Sie die Methode strftime() von date-, datetime- und time-Objekten benutzen:>>> import time>>> termin = time.strftime('%d.%m.%y')>>> print("Abgabetermin ist der", termin)Abgabetermin ist der 29.04.19str.format()Für die formatierte Ausgabe von anderen Zahlen, z.B. Währungsbeträgen gibt es eine Reihe von verschiedenen Funktionen wie die Nutzung von Formatierungen in der print()-Funktion. Empfohlen wird aber die Verwendung der String-Methode format().Um format zu verwenden, legen Sie zunächst ein String mit Platzhaltern für Werte an. Diese Platzhalter werden durch geschweifte Klammern gekennzeichnet. In den geschweiften Klammern steht ein Index. >>> "Platzhalter 1: {0} Platzhalter 2: {1}"'Platzhalter 1: {0} Platzhalter 2: {1}'Für dieses String-Objekt rufen Sie nun die Methode Format mit einem oder mehreren Argumenten auf. Der Wert dieser Argumente von format() wird für die Platzhalter eingesetzt. Das erste Argument hat den Index 0, das 2. Argument hat den Index 1, das 3. Den Index 3 usw.>>> "Platzhalter 1: {0} Platzhalter 2: {1}".format(11, 22)'Platzhalter 1: 11 Platzhalter 2: 22'>>>Platzhalter können zusätzlich zum Index eine Formatangabe enthalten. Die Schreibweise ist:{[Index]:[Feldbreite][Datenformat]}Wenn Sie eine Zeichenkette erzeugen wollen, die eine ganze Zahl in einem Textfeld mit einer Breite von fünf Zeichen und einen Betrag in einem Feld mit einer Breite von 8 Zeichen mit 2 Nachkommastellen rechtsbündig darstellt, gehen Sie wie im folgenden Beispiel vor:>>> ausgabe_zeile = "Artikelnr: {0:5d}, Stückpreis: {1:8.2f}">>> ausgabe_zeile.format(99, 125.777)'Artikelnr:    99, Stückpreis:   125.78'>>> ausgabe_zeile.format(100, 25.0)'Artikelnr:   100, Stückpreis:    25.00'>>> ausgabe_zeile.format(101, 713.05)'Artikelnr:   101, Stückpreis:   713.05'Die beiden Zahlen sind rechtsbündig ausgerichtet und die Zahl mit Nachkommastellen wird auf die zweite Nachkommastelle gerundet ausgegeben.Die folgende Tabelle enthält einige Elemente von Datenformaten, die Sie benutzen können:DatenformatBedeutungi oder dGanze Zahl mit Vorzeichen, rechtsbündig, dezimaluGanze Zahl ohne Vorzeichen, rechtsbündig, dezimalfFliesskomazahl mit Vorzeichen, rechtsbündig, dezimale oder EFliesskomazahl mit Vorzeichen, rechtsbündig in Exponentialschreibweise. Kleinbuchstaben bei e, Grossbuchstaben bei Ex oder XGanze hexadezimale Zahl mit Vorzeichen. Kleinbuchstaben bei x, Grossbuchstaben bei XbBinärzahl mit VorzeichensZeichenkette (String)cEinzelnes ZeichenZusätzlich können Sie die Auffüllung und Ausrichtung des Feldes (rechts,links, zentriert) und das Einfügen zusätzlicher Zeichen beeinflussen:{[Index]:[Ausrichtung][Feldbreite][Datenformat]}Einige Ausrichtungs- und Auffülloptionen finden Sie in der folgenden Tabelle:Ausrichtungs-OptionBedeutung#Bei hexadezimaler und binärer Darstellung wird dem Wert 0x bzw. 0b vorangestellt.0Das Feld wird mit Nullen aufgefüllt<Der Wert im Feld linksbündig angeordnet>Der Wert im Feld rechtsbündig angeordnet (Default bei Zahlenformaten)^Der Wert im Feld wird zentriert angeordnetSie können weiterhin beinflussen, wie Vorzeichen behandelt werden:{[Index]:[Ausrichtung][Vorzeichenoption][Feldbreite][Datenformat]}Vorzeichen-OptionBedeutung+Das Vorzeichen wird auch bei positiven Zahlen ausgegeben-Das Vorzeichen wird nur bei positiven Zahlen ausgegebenLeerzeichenBei positiven Zahlen wird statt des Minus-Zeichens ein Leerzeichen eingefügt11.6 Typ-UmwandlungenSie kennen bereits die Umwandlung einer mit input() eingegelesenen Zeichenkette in Zahlen mit den Funktionen int() und float(). Umgekehrt können auch Zahlen in Strings umgewandelt werden:>>> eine_zahl = 11>>> ein_string = str(eine_zahl)>>> ein_string'11'>>> eine_zahl = 11>>> ein_string = float(eine_zahl)>>> ein_string'11.0'>>>Dies kann nützlich sein, wenn Sie einen Zahlenwert in einen Text einfügen wollen. Auch eine Umwandlung von Listen in Strings scheint mit der Funktion str() möglich zu sein, das Ergebnis ist aber nicht das, was man erwartet:>>> worte = ['Aus', 'sechs', 'Worten', 'wird', 'ein', 'Satz']>>> str(worte)"['Aus', 'sechs', 'Worten', 'wird', 'ein', 'Satz']"Besser funktioniert es mit der Str-Methode join(). Sie fügt die Elemente einer Liste von Strings zusammen und fügt den Inhalt eines weiteren Strings zwischen den Elementen ein. >>> s1 = '-'>>> s1.join([‘a’, ‘b’, ‘c’)'a-b-c'Im nächsten Beispiel wird für den Aufruf von join() ein String-Literal mit einem Leerzeichen benutzt. Denken Sie daran: auch das Literal ist ein str-Objekt, das über die Methode join verfügt.>>> worte = ['Aus', 'sechs', 'Worten', 'wird', 'ein', 'Satz']>>> satz = ' '.join(liste)>>> satz'Aus sechs Worten wird ein Satz'Diese Methode kann nützlich sein, wenn Sie in einem Programm einen Text aus verschiedenen Teilen zusammensetzen wollen.Wenn Sie einen String in einzelne Zeichen aufteilen wollen, verwenden Sie dir Funktion list()>>> text = 'Aber warum?'>>> list(text)['A', 'b', 'e', 'r', ' ', 'w', 'a', 'r', 'u', 'm', '?']>>>Um einen Text in eine Liste von Wörtern umzuwandeln, benötigen Sie die Methode split(). Dabei wird jeder Teil des Textes, der keinen Whitespace (Leerzeichen, Tabulatoren und Zeilenumbrüche) enthält als ein Wort betrachtet. Ein Beispiel:>>> text = """My Hoovercraft is full of eels... 12$... ... 444""">>> text.split()['My', 'Hoovercraft', 'is', 'full', 'of', 'eels', '12$', '444']Bei split() kann auch ein anderes Trennzeichen als «Whitespace» verwendet werden. Das gewünschte Trennzeichen übergeben Sie als Parameter:>>> text = 'erstes Feld;zweites Feld;drittes Feld'>>> text.split(';')['erstes Feld', 'zweites Feld', 'drittes Feld']11.7 String-Inhalte untersuchenEs gibt eine Reihe von Methoden des Typs str, mit denen der Inhalt einer Zeichenkette auf bestimmte Zeichen überprüft werden kann. Sie geben als Resultat True oder False zurückstr.isdecimal()str.isdigit()str.isnumeric()Diese Methoden liefern den Wert True, wenn der String mindestens ein Zeichen enthält und alle Zeichen Zahlzeichen sind, ansonsten False. Für Strings, die nur aus den Zeichen 0 bis 9 bestehen, verhalten sich die drei Methoden gleich, sie unterscheiden sich aber bei der Behandlung von speziellen Unicode-Zeichen wie den hochgestellten Zahlen in Potenz-Ausdrücken.str.isalpha()Liefert True, wenn der String mindestens ein Zeichen enthält und dieses Zeichen alphabetisch iststr.isalnum()	Liefert True, wenn eine der folgenden Methoden True liefert: str.isalpha() or str.isdecimal() or str.isdigit() or str.isnumeric()str.isspace()	Liefert True, wenn der String nicht leer ist und ausschliesslich sogenannten «Whitespace» wie Leerzeichen oder Tabulatoren enthält.str.startswith(substring)Liefert True, wenn der String nicht leer ist und mit mit der Zeichenkette substring beginnt.str.endswith(substring)Liefert True, wenn der String nicht leer ist und mit der Zeichenkette substring endet.str.find(substring)Sucht im String nach dem substring und liefert bei Erfolg den Index im String, an dem der substring das erste Mal auftritt. Bei Misserfolg ist der Rückgabewert -1str.index(substring)Wie find(), aber bei Misserfolg wird die Exception ValueError ausgelöst.11.8 Zusammenfassung• Strings repräsentieren Text, können aber auch als Aufzählung von einzelnen Zeichen behandelt werden, wobei die Zeichen wiederum vom Typ str sind• Der Inhalt von String-Objekten ist immutable (unveränderlich) • Es gibt eine grosse Anzahl von Möglichkeiten, um einen String zu formatieren. Sie alle geben als Ergebnis neuen String zurück• Mit weiteren Methoden wie isdecimal(), die True oder False zurückgeben, kann man Strings auf bestimmte Inhalte untersuchen• Die Dokumentation zu Strings findet man unter:https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str11.9 Aufgaben1) Probieren Sie zunächst die Methoden aus Kapitel 11.7 in der REPL mit verschiedenen Strings aus. Schreiben Sie dann ein Programm string_eigenschaften.py, das Ihre Eingabe auf verschiedene Eigenschaften hin untersucht. Beispiel:$ python string_eigenschaften.pyGeben Sie eine Zeichenkette ein: Sommerstr.isdecimal() ergibt: Falsestr.isnumeric() ergibt: Falsestr.isdigit() ergibt: Falsestr.isalpha() ergibt: Truestr.isalnum() ergibt: Truestr.isspace() ergibt: False$2) Schreiben Sie ein Programm eingabe_liste.py, das in einer einzelnen Eingabe eine beliebige Menge von Werten, die durch Leerzeichen getrennt sind, einliest, sie in eine Liste umwandelt und anschliessend die Listenelemente nacheinander ausgibt. Beispiel:$ python eingabe_liste.pyEingaben, durch Leerzeichen getrennt: erste zweite dritte EingabeerstezweitedritteEingabe$3) Scheiben Sie ein Programm format_ausgabe.py, das aus einer Liste von Netto-Preisen und einem Steuersatz eine Ausgabe wie die folgende erzeugt. Verwenden Sie dazu die Eingabemethode, die Sie in eingabe_liste.py verwendet haben.$ python format_ausgabe.pyEingabe der Nettopreise, durch Leerzeichen getrennt: 1234.02 23.0 97685.22Steuersatz in %: 7.7          Netto          Brutto        1234.02         1329.04          23.00           24.77       97685.22       105206.984) Schreiben Sie ein Programm dec_to_bin_hex.py, das eine ganze Dezimalzahl einliest und als Binärzahl sowie als hexadezimale Zahl ausgibt. Ein Beispiel:Python dec_to_bin_hex.pyDezimalzahl: 255Binäre Darstellung: 11111111Hexadezimale Darstellung: FF5) Schreiben Sie ein Programm substring.py, das ein Wort auf das Vorkommen eines Substrings untersucht. Ein Beispiel:$ python substring.py Wort und Suchstrings: dampfschifffahrtsgesellschaft tzt schiff fahrt dampf kramschiff gefundenfahrt gefundendampf gefunden6) Modifizieren Sie ein Programm lotto1.py aus Kapitel 10.11 so, dass die Eingabe des Lottotipps auf einer Zeile erfolgen kann. Ein Beispiel:$ python lotto2.pyGeben Sie Ihren Tipp ein. (6 Zahlen von 1 bis 49): 1 50 2 33 11 quatsch 23 44Ziehung: [1, 2, 16, 20, 38, 43]Ihr Tipp: [1, 2, 11, 23, 33, 44]Richtige: 2 [1, 2]$Falsche Eingabebestandteile (Keine Zahl, Zahl schon einmal angegeben) und zu viel eingegebene Zahlen sollen einfach ignoriert werden. Tipp: Benutzen sie die String-Methode str.split() bei der Eingabe.12 Ausnahmen behandelnBei der Ausführung von Python-Programmen kann es zu verschiedenen Fehlern kommen, die als «Exception» (Ausnahme) bezeichnet wird. Wahrscheinlich haben Sie bei Ihren Experimenten mit Python bereits häufiger solche Fehler verursacht. Sie haben möglicherweise bei Programmen mit einer Eingabeaufforderung ausprobiert, was passiert, wenn Sie keine Zahl angeben. >>> int(input('Geben Sie eine Zahl ein: '))Geben Sie eine Zahl ein: siebenTraceback (most recent call last):  File "<stdin>", line 1, in <module>ValueError: invalid literal for int() with base 10: 'sieben'>>> float(input('Geben Sie eine Zahl ein: '))Geben Sie eine Zahl ein: 1,0Traceback (most recent call last):  File "<stdin>", line 1, in <module>ValueError: could not convert string to float: '1,0'>>>Das Ergebnis ist in beiden Fällen eine Fehlermeldung. Leider bricht Python nach dem Auftreten dieser Fehler das gesamte Programm ab. Es wäre natürlich besser, wenn Sie den Fehler selbst abfangen könnten.12.1 LernzieleNach der Bearbeitung dieses Kapitels können Sie• Ausnahmen bei der Ausführung Ihrer Programme abfangen• Das Konstrukt try … except … finally sinvoll einsetzen, um auf Ausnahmen zu reagieren• Umwandlung von Strings in Zahlen verbessern12.2 Die Eingabe von Zahlen verbessernIm vorigen Kapitel haben Sie einige String-Methoden kennengelernt, mit denen das gelingen könnte. Die String-Methode isdecimal() prüft beispielsweise, ob ein String mindestens ein Zeichen und ausschliesslich Zahlzeichen enthält. Eine Eingabe könnte damit wie folgt geprüft werden:Leider funktioniert das nur für positive ganze Zahlen, wie der folgende Test zeigt:$ python ist_zahl1.pyGeben Sie eine ganze Zahl ein: 1.0Ihre Eingabe ist keine ganze ZahlGeben Sie eine ganze Zahl ein: abcIhre Eingabe ist keine ganze ZahlGeben Sie eine ganze Zahl ein: -9Ihre Eingabe ist keine ganze ZahlGeben Sie eine ganze Zahl ein: 100Die Zahl ist  100$Ein besserer Weg, dieses Problem zu lösen ist die Benutzung der Ausnahmebehandlung in Python. Wann immer eine sogenannte Ausnahme (Exception) wie etwa ein ValueError auftritt, ist es das Standardverhalten des Interpreters, das Programm mit einer Fehlermeldung abzubrechen. Sie können eine Exception aber auch abfangen und darauf reagieren. Dazu müssen Sie die Stelle im Programm, an der eine Exception auftreten könnte, innerhalb einer try-Suite einschliessen. try:    Anweisung(en), die zu Exceptions führen könnenexcept:    Anweisungen, die nach aufgetretenen Exceptions ausgeführt werdenDann wird das Programm nicht mehr einfach abgebrochen wenn eine Exception auftritt. Stattdessen wird der Code nach except: ausgeführt. Hinter except kann noch angegeben werden, auf welche Exceptions reagiert werden soll.Dies kann für die Konvertierung eines Strings in einen int-Wert oder float-wert genutzt werden:Nun funktioniert das Ganze auch bei negativen Zahlen. $ python ist_zahl2.pyGeben Sie eine ganze Zahl ein: 1.0Ihre Eingabe ist keine ganze Zahl.Geben Sie eine ganze Zahl ein: abcIhre Eingabe ist keine ganze Zahl.Geben Sie eine ganze Zahl ein: -99Die Zahl ist:  -99$12.3 Andere ExceptionsEine Division durch 0 ist nicht erlaubt, kann aber trotzdem auftreten, zum Beispiel im folgenden Programm:Gibt der Benutzer hier den Wert 0 ein, tritt ein ZeroDivisionError auf, der aber abgefangen wird$ python div_null.pyZähler: 1Nenner: 20.5$ python div_null.pyZähler: 5Nenner: 0Division durch 0 ist nicht erlaubt0.0$Weitere Arten von Exceptions, die Sie mit try und exept abfangen können, sind beispielsweise: OverflowError, FloatingPointError, IndexError, KeyError, IOError, ImportError und KeyboardInterrupt.Die Dokumentation hierzu finden Sie unter:https://docs.python.org/3/library/exceptions.htmlDies sind vordefinierte Exceptions. Programmierer können auch eigene Exceptions definieren und diese mit try: / except: abfangen. Dazu erfahren Sie mehr in einem späteren Kapitel.12.4 Verschiedene Exceptions in einer try-SuiteSind mehrere Exceptions im Code nach try: möglich, können diese separat behandelt werden, wie das folgende Beispiel zeigt, bei dem sowohl ein ValueError wie auch ein ZeroDivisionError auftreten können. Je nach Fehlerart wird eine der beiden except-Aktionen ausgeführt:$ python multi_exception.pyZähler: rtzFehler bei der Umwandlung str -> int$ python multi_exception.pyZähler: 1Nenner: 0Division durch 0 ist nicht erlaubt$ python multi_exception.pyZähler: 2Nenner: 4Wert an Listen-Index: 3Der Index liegt ausserhalb des Bereichs für diese ListeWird die Fehlerart nach except: nicht explizit angegeben, werden die Anweisungen danach für jede mögliche Exception ausgeführt, die nach try: auftritt.12.5 FinallyZu einer try-except Suite kann noch das optionale Schlüsselwort finally: hinzugefügt werden. Der Code, der dort steht, wird immer ausgeführt, gleichgültig ob eine Exception aufgetreten ist oder nicht. Dort können Sie bei Bedarf Aufräum- und Abschlussaktivitäten unterbringen.try:    Anweisung(en), die zu Exceptions führen könnenexcept:    Anweisungen, die nur beim Auftreten von Exceptions ausgeführt werdenfinally:    Anweisungen, die in jedem Fall ausgeführt werden12.6 Zusammenfassung• Verschiedene Fehler, die bei der Ausführung eines Programms auftreten können, führen zu einer sogenannten Exception.• Die Standardreaktion des Python-Interpreters auf eine solche Exception ist der sofortige Abbruch des Programms• Wenn der Programmierer den Code innerhalb einer try:-Suite platziert, kann er die Exception abfangen und die Fehlersituation sinnvoll behandeln, z.B. indem er nach dem Schlüsselwort except: eine für den Benutzer sinnvolle Fehlermeldung ausgibt. Das Programm kann danach weiterlaufen.• Das try:-except:-Konstrukt kann mir einer optionalen finally:-Suite erweitert werden.• Es gibt einige vordefinierte Exceptions. Programmierer können auch eigene Exceptions definieren und diese mit try: / except: abfangen.12.7 Aufgaben1) Verändern Sie das Programm  ist_zahl2.py so, dass auch die Eingabe einer Fliesskommazahl nicht zu einer Fehlermeldung führt. Die Eingaben 4.0 und 4.23 sollen dann einfach in die ganze Zahl 4 umgewandelt werden2) Suchen Sie in Programmen, die Sie bereits geschrieben haben, nach Situationen, in denen Exceptions wie , IndexError, ValueError oder ZeroDivisionError auftreten können und modifizieren Sie diese Programme so, dass diese Exceptions nicht mehr zu einem Programmabbruch führen, wenn sie auftreten.13 Eigene FunktionenSie haben schon eine Vielzahl von vordefinierten Funktionen genutzt. Eigene Funktionen bieten Ihnen die Möglichkeit, mehrfach benötigten Code an nur einer Stelle zu schreiben, aber an beliebig vielen Stellen zu verwenden. 13.1 LernzieleNach der Bearbeitung dieses Kapitels können Sie:• Eigene Funktionen erstellen• Diese Funktionen in Ihren Programmen aufrufen und ihnen Argumente übergeben• Werte aus Funktionen zurückgeben und diese Werte in Ihren Programmen zu nutzen13.2 Warum eigene Funktionen schreiben?Nehmen Sie an, dass in einem Ihrer Programme an drei verschiedenen Stellen Zahlen eingegeben werden müssen. Nach dem, was Sie bisher wissen, würden Sie dreimal den folgenden Code eingeben:    try:        zahl = int(input('Geben Sie eine ganze Zahl ein: '))        konvertiert = True    except ValueError :        print('Ihre Eingabe ist keine ganze Zahl.')Das kann natürlich leicht mit Copy/Paste erledigt werden, aber dieses Vorgehen hat gravierende Nachteile:1) Der Programmcode wird insgesamt länger und unübersichtlicher2) Wenn Sie in einem kopierten Programmteil einen Fehler ebtdecken, müssen Sie diesen Fehler gleich an drei Stellen im Programm beheben3) Es könnte Sein, dass Sie den Fehler an zwei Stellen korrigieren, aber die dritte Stelle vergessen4) Wenn Sie keinen Fehler machen, aber an Ihrem Code nachträglich etwas ändern wollen, müssen Sie das an mehreren Stellen tun. Auch hier besteht die Gefahr, dass Sie die Änderung nicht überall durchführen.5) Wenn Sie diese Eingabe in einem mehreren Programmen benutzen und nachträglich ändern wollen, steigen der Aufwand, die Unübersichtlichkeit und die Zahl der Fehlerquellen nochmals um ein Vielfaches an.In der Programmierung gilt deshalb das DRY-Prinzip («Don’t Repeat Yourself»). Wiederholt benötigte Codezeilen sollten an einer Stelle zusammengefasst werden, aber an verschiedenen Stellen benutzbar sein. Das ist genau das Prinzip von Funktionen.13.3 Eine eigene Funktion schreibenEine Funktion wurde im Kapitel 5.2 wie folgt erklärt:Eine Funktion ist ein Stück bestehender Programmcode, das Sie als Programmierer benutzen können ohne den genauen Inhalt zu kennen. Es reicht, wenn Sie wissen, was die Funktion tut und wie ihre Signatur ist. Die Signatur einer Funktion hat die folgenden Bestandteile:Rückgabewert = Funktionsname ( Parameter1,  Parameter2, . . . , Parametern  )Um eine solche Funktion selbst zu erstellen, müssen Sie also einen Namen vergeben, eine Liste von Parametern angeben und allenfalls einen Wert zurückgeben. Wie das geht, sehen Sie an folgendem Beispiel: Eine eigene Funktion maximum(wert1, wert2) soll zwei Zahlenwerte vergleichen und den grösseren Wert von beiden zurückgeben.def maximum(wert1, wert2) :    if wert1 > wert2:        return wert1;    else:        return wert2Die Definition der Funktion maximum() beginnt mit dem Schlüsselwort def. Danach steht der Name der Funktion sowie eine Liste der Parameter in Klammern hinter dem Namen, dann kommt der Doppelpunkt und danach eine eingerückte Suite von Anweisungen. Die Parameter wert1 und wert2 können in dieser Suite wie Variablen verwendet werden. Je nach den übergebenen Werten wird die Anweisung return wert1 oder return wert2 ausgeführt. Dann wird die Funktion beendet und es wird entweder wert1 oder wert2 zurückgegeben.Die Funktion wird dann später im Programm aufgerufen:print(maximum(1, 2))print(maximum(2, 1))print(maximum(1, 1))Die Ausgabe ist:221Eine Funktion read_int(prompt), die das einleitende Beispiel aufnimmt, gibt eine Eingabeaufforderung aus, wandelt die Benutzerausgabe in einen int-Wert um und gibt diesen Wert als Ergebnis zurück: In den Zeilen 1 bis 8 wird die Funktion definiert. Die Eingabeaufforderung kann der Funktion als Parameter prompt übergeben werden und wird dann einfach an die vordefinierte Funktion input() weitergereicht. Wenn die Umwandlung nicht gelingt, wird eine Fehlermeldung ausgegeben und die Eingabeaufforderung solange erneut ausgegeben, bis eine ganze Zahl eingegeben wird. Dann wird Zeile 6 in der Funktion erreicht, die mit return die Zahl zurückgibt. In den Zeilen 10 bis 13 wird die Funktion getestet. Ein Beispiel für die Ausführung dieses Programms ist:$ python read_int_demo.py"Anzahl: 1212Ihr Alter: vierzigDie Eingabe ist keine ganze ZahlIhr Alter: 4040$Das folgende Bild verdeutlicht, was dabei passiert:Abbildung 131 - Übergabe eines Arguments und Rückgabewert1. Beim ersten Aufruf wird der Funktion read_int() als Argument der String 'Anzahl: ' übergeben. 2. Nach der erfolgreichen Eingabe einer Zahl kehrt die Programmausführung zum Hauptprogramm zurück. Der Rückgabewert ist 12 und der wird der Variablen anzahl zugewiesen.3. Beim zweiten Aufruf wird der Funktion read_int() als Argument der String 'Ihr Alter: ' übergeben. 4. Nach der erfolgreichen Eingabe einer Zahl kehrt die Programmausführung zum Hauptprogramm zurück. Der Rückgabewert ist 40 und der wird der Variablen alter zugewiesen.13.4 Platzierung von FunktionsdefinitionenWenn Sie eine Funktion in einem Programm definieren, muss die Definition mit def vor dem ersten Aufruf der Funktion stehen. Wird diese Reihenfolge nicht eingehalten, gibt es eine Fehlermeldung:$ python reihenfolge.py30Traceback (most recent call last):  File "reihenfolge.py", line 9, in <module>    print(differenz(10, 20))NameError: name 'differenz' is not defined$Es ist nicht zwingend, die Definitionen aller Funktionen, die im Programm verwendet werden, an den Anfang des Programms zu stellen aber es ist ein guter Programmierstil. Das vermeidet Fehler und macht Ihr Programm lesbarer.Funktionen, von denen Sie annehmen, dass Sie sie in verschiedenen Programmen brauchen werden, können Sie auch in eine separate Datei ausgelagern. Im folgenden Beispiel sehen Sie den Inhalt der Datei myfunctions.py:Liegt diese Datei im gleichen Dateiverzeichnis wie ihr Programm, können Sie die Funktionen importieren:Wie Sie an diesem Beispiel sehen, funktioniert der Import aus der Datei myfunctions.py genauso wie der Import aus einem Modul. Sie könnten auch das gesamte Modul importieren und die Funktion mit modulname.funktionsname() aufrufen:Das bedeutet:• Ein Modul ist eine ganz normale Python-Datei, die beispielsweise Ihre eigenen Funktions-Definitionen enthält• Sie können die Funktionen in diesem Modul in allen Programmen nutzen, ohne auf Copy/Paste zurückgreifen zu müssen. Sie müssen dazu nur die Funktion oder das komplette Modul in Ihre Programme importieren.Muss das Modul im gleichen Verzeichnis stehen, wie Ihr Programm? Nein, denn der Python-Interpreter sucht es an verschiedenen anderen Stellen, wenn es nicht im gleichen Verzeichnis steht. Wo genau er sucht, hängt teilweise von ihrer Betriebssystemplattform und von der Art der Installation ab. Sie können Sich die verschiedenen Verzeichnisse aber leicht mittels folgender Abfrage anzeigen lassen (Beispiel: Installation des Autors auf Mac OSX):>>> import sys>>> for dir in sys.path :...     print(dir)... /Library/Frameworks/Python.framework/Versions/3.7/lib/python37.zip/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/lib-dynload/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packagesBitte speichern Sie für das Erste Ihre Module einfach im gleichen Verzeichnis wie Ihre Programme, Sei werden weitere Informationen zu Modulen in einem weiterführenden Kapitel erhalten.13.5 Parameter und DatentypenBetrachten Sie das folgende Beispiel:>>> def summe(wert1, wert2):...     return wert1 + wert2... >>> ergebnis = summe( 10, 20 )>>> print(ergebnis)30>>> ergebnis = summe( 'Hallo ', 'Welt!' )>>> print(ergebnis)Hallo Welt!Bei der Definition der Funktion summe() wurde sicherlich beabsichtigt, das zwei Zahlen summiert werden sollen. Wie sie sehen, funktioniert aber auch der Aufruf mit zwei String-Argumenten und er gibt sogar ein einigermassen sinnvolles Ergebnis zurück!Der Grund dafür ist, dass der Operator + sowohl für Zahlen als auch für Strings funktioniert. Anders sieht das bei der Funktion im folgenden Beispiel aus:>>> def differenz(wert1, wert2):...     return wert1 - wert2... >>> ergebnis = differenz( 'Hallo ', 'Welt!' )Traceback (most recent call last):  File "<stdin>", line 1, in <module>  File "<stdin>", line 2, in differenzTypeError: unsupported operand type(s) for -: 'str' and 'str'Für Strings existiert kein Operator - , so dass der Code innerhalb der Funktion differenz() zu einem TypeError führt, wenn nicht beide Argumente beim Aufruf der Funktion Zahlen sind.Sie erinnern sich vielleicht, dass Variablen in Python jederzeit den Datentyp wechseln können, je nachdem welcher Wert ihnen zugewiesen wird. Das sinngemäss gleiche Verhalten gilt bei Argumenten bzw. Parametern von Funktionen. Es gibt daher keinen Weg, dem Python-Interpreter die Aufgabe zu übertragen, den korrekten Aufruf Ihrer Funktion mit ArgumentenWollen Sie sicheren Code schreiben, müssen Sie selbst überprüfen, ob die Datentypen korrekt sind. Das geht meistens am besten mit try: und except:>>> def summe(wert1, wert2):...     try:...         return int(wert1) + int(wert2)...     except ValueError:...         print(wert1, "+", wert2, ": Falscher Datentyp!")... >>> wert=summe(1, "Eins")1 + Eins : Falscher Datentyp!13.6 Rückgabewerte und DatentypenDa Python ein dynamisches Typsystem besitzt, kann der Interpreter auch nicht sicherstellen, dass der Rückgabewert Ihrer Funktion richtig verwendet wird. Im folgenden Beispiel wird der Versuch gemacht, der Variablen name vom Typ str den Rückgabewert der Funktion summe() aus dem vorigen Abschnitt zuzuweisen:>>> name='unbekannt'>>> print(name)unbekannt>>> type(name)<class 'str'>>>> name=summe(10, 20)>>> print(name)30>>> type(name)<class 'int'>Das Beispiel zeigt, dass durch die Zuweisung des Funktionsresultats von summe() der Datentyp der Variablen name einfach geändert wird. Es gibt keine Fehlermeldung und auch keinen ValueError. Das bedeutet, dass Sie allenfalls auch bei der Zuweisung von Funktionsresultaten Prüfungen einbauen müssen.In einer Funktion muss nicht zwingend eine return-Anweisung vorkommen. Welchen Rückgabewert hat aber eine Funktion in diesem Fall? Betrachten Sie das folgende Beispiel:>>> def noreturn(p):...     print(p)...>>> wert = noreturn(99)99>>> print(wert)NoneDer spezielle Wert None (‘Kein Wert’) wird von vielen Funktionen zurückgegeben, z.B. von print():>>> wert = print("Hallo")Hallo>>> print(wert)NoneNone hat sogar einen eigenen Datentyp, class ‘NoneType’:>>> type(wert)<class 'NoneType'>Den Wert None können Sie auch explizit mit return zurückgeben, wie das folgende Beispiel zeigt:>>> def summe(wert1, wert2):...     try:...         return int(wert1) + int(wert2)...     except ValueError:...         return None... >>> ergebnis = summe( 'Hallo ', 'Welt!' )>>> print(ergebnis)None13.7 Anzahl Argumente und RückgabewerteIm Gegensatz zur fehlenden Überprüfung der Datentypen der Argumente prüft der Interpreter, ob Sie die richtige Anzahl Argumente übergeben haben:>>> def summe(wert1, wert2):...     return wert1 + wert2... >>> ergebnis = summe( 1 )Traceback (most recent call last):  File "<stdin>", line 1, in <module>TypeError: summe() missing 1 required positional argument: 'wert2'>>>Mit Return können Sie nur genau ein Objekt zurückgeben. Falls Sie mehrere Rückgabewerte benötigen, können Sie eine Liste von Werten verwenden:Die Ausführung ergibt:$ python return_list.py[0, 1, 2, 3, 4, 5, 6, 7, 8]$13.8 FunktionsannotationenIn neueren Python-Programmen sehen Sie eventuell die folgende Schreibweise in einer Funktionsdefinition:Die Angaben nach den Doppelpunkten hinter den Funktionsparametern und hinter dem -> nach der Parameterklammer werden Annotationen genannt. Im Beispiel der Funktion zahlstring() bedeuten sie:zahlenwert: int		# Das Argument zahlenwert soll vom Typ int seinzahlstring(zahlenwert: int) -> str # Der Rückgabewert ist vom Typ strAllerdings bewirken diese Annotationen nicht, dass der Datentyp des Arguments oder des Rückgabewerts oder der Typ einer Variablen, die den Rückgabewert zugewiesen bekommt vom Python-Interpreter geprüft würden. Es ist weiterhin möglich, die falschen Datentypen zu verwenden. Wozu also der Aufwand? Annotationen machen Ihren Code lesbarer. Sie sehen auf einen Blick, was für Typen die Argumente haben sollten und Sie müssen nicht erst den Code der Funktion lesen, um zu verstehen was für einen Typ der Rückgabewert hat. Benutzen Sie deshalb möglichst immer Funktionsannotationen!13.9 Lokale und globale VariablenEine Variable, die innerhalb einer Funktion definiert wird, ist immer lokal. Das heisst, sie gilt nur innerhalb der Funktion. Ein Beispiel dafür:>>> def funktion1():...     lokale_zahl = 11...     print("lokale_zahl in funktion1:", lokale_zahl)... >>> funktion1()lokale_zahl in funktion1: 11>>> print("lokale_zahl im Hauptrogramm:", lokale_zahl)Traceback (most recent call last):  File "<stdin>", line 1, in <module>NameError: name 'lokale_zahl' is not definedEine Variable, die im Hauptprogramm vor dem Funktionsaufruf definiert wurde ist global. Sie gilt im Hauptprogramm und auch innerhalb aller Funktionen. Ein Beispiel dafür:>>> def funktion2():...     print(zahl)... >>> zahl = 22>>> funktion2()22Gibt es eine globale Variable, die im Hauptprogramm vor dem Funktionsaufruf definiert wurde, gilt sie auch innerhalb der Funktion. Wenn aber innerhalb der Funktion eine lokale Variable mit dem gleichen Namen definiert wurde, hat sie Vorrang vor der globalen Funktion. Für den gleichen Variablennamen findet man dann möglicherweise innerhalb der Funktion einen anderen Wert als ausserhalb. Ein Beispiel dafür:>>> def funktion3():...     zahl = 22...     print("In funktion3:", zahl)... >>> zahl = 11>>> funktion3()In funktion3: 22>>> print("Im Hauptprogramm:", zahl)Im Hauptprogramm: 11Die Variable zahl hat zwar innerhalb der Funktion den gleichen Namen, aber es handelt sich um eine andere Variable als zahl im Hauptprogramm. Ein Name hat eine Gültigkeit für einen bestimmten Namensraum. Innerhalb der Funktion funktion3() gilt ein eigener Namensraum, daher kann problemlos der gleiche Name verwendet werden. Er verweist auf die lokale Variable zahl in der Funktion mit dem Wert 22. Nach Beendigung der Funktion gilt wieder der Namensraum des Hauptprogramms, die globale Variable zahl hat dort den Wert 11:Abbildung 132 Globaler und lokaler NamensraumIm Beispiel mit funktion2() haben Sie gesehen, dass Sie in einer Funktion auf globale Variablen lesend zugreifen können. Was passiert, wenn Sie den Wert einer globalen Variablen in einer Funktion verändern wollen, sehen Sie im folgenden Beispiel:>>> def funktion4():...     zahl = zahl + 1... >>> zahl = 9>>> funktion4()Traceback (most recent call last):  File "<stdin>", line 1, in <module>  File "<stdin>", line 2, in funktion4UnboundLocalError: local variable 'zahl' referenced before assignmentDie Fehlermeldung erscheint zunächst etwas unverständlich zu sein, denn im Beispiel mit funktion2() konnten Sie problemlos auf den Wert der globalen Variablen zahl zugreifen. Offenbar macht es einen Unterschied, ob Sie den Wert nur lesen, wie mit print(zahl) in der funktion2() oder ob Sie den Wert verändern wollen wie mit der Anweisung zahl = zahl + 1 in funktion4(). Die Fehlermeldung sagt aus, dass eine lokale Variable zahl benutzt wird, bevor ihr einen Wert zugewiesen wurde.Der Python-Interpreter legt mit der Anweisung zahl = zahl + 1 in funktion4() zunächst eine neue lokale Variable zahl auf der linken Seite des Gleichheitszeichens an. Da dieser Name nun gleich dem Namen der globalen Variablen zahl ist und lokale Variablennamen Vorrang gegenüber gleichlautenden globalen Variablennamen haben, wird zahl auf der rechten Seite des Gleichheitszeichens ebenfalls als die lokale Variable zahl angesehen. Diese hat aber zu diesem Zeitpunkt noch keinen Wert zugewiesen bekommen und verweist noch nicht auf ein Objekt:Abbildung 133 Fehlerhafte Verwendung einer lokalen Variable vor einer WertzuweisungDamit der Wert einer globalen Variablen in einer Funktion erfolgreich verändert werden kann, muss sie daher mit dem Schlüsselwort global als globale Variable gekennzeichnet werden, wie im folgenden Beispiel:>>> def funktion5():...     global zahl...     zahl = zahl + 1... >>> zahl = 9>>> funktion5()>>> print(zahl)10In diesem Fall legt der Python-Interpreter keine lokale Variable zahl an und es gibt keinen Konflikt:Abbildung 134 Verwendung von global in einer Funktion13.10 Variablen als FunktionsargumenteWie Sie bereits bei vielen Funktionen der Standardbibliothek gesehen haben, können einer Funktion können auch Variablen als Argumente übergeben werden. Diese können in der Funktion als lokale Variablen verwendet werden. Was passiert dann mit den Werten, die diese Variablen haben?Das folgende Beispiel zeigt die Übergabe einer int-Variable zahl an die Funktion malzwei(), die den übergebenen Wert mit 2 multipliziert:>>> def malzwei(wert):...     print(wert)...     wert = wert * 2...     print(wert)... >>> zahl=4>>> malzwei(zahl)48>>> print(zahl)4Die Variable zahl wird in der Funktion nach Aufruf von malzwei(zahl) über den Parameter wert zwar verändert, hat aber nach dem Funktionsaufruf unverändert den Wert 4. Er. Ein weiteres Experiment verwendet eine Liste und einen String als Argumente:>>> def change_list(par):...     par[0] = 'X'. # Ein Element wird verändert... >>> liste = [ 'A', 'B', 'C' ]>>> change_list(liste)>>> liste['X', 'B', 'C']Hier wird der Inhalt der Variable liste offensichtlich verändert. Der Grund für den unterschiedlichen Umgang mit Variablen als Funktionsparameter liegt darin, dass die Variable zahl und damit auch der Parameter wert in malzwei() im ersten Beispiel vom Typ int sind. Objekte vom Typ int sind unveränderlich (immutable). Die Variable liste uns der Parameter liste in change_list() im zweiten Beispiel ist vom Typ list und Objekte dieses Typs sind veränderlich (mutable).Was in der Funktion malzwei() passiert, zeigt Abbildung 135. In der Funktion Funktion malzwei() verweist der Parameter wert zunächst auf Objekt1, auf das auch die Varaiable zahl im Hauptprogramm zeigt. Sobald der Interpreter auf die Anweisung stösst, die den Inhalt des Objekts verändern wird, legt er eine Kopie des Objekts (Objekt2) an und wert verweist jetzt nicht mehr auf das Objekt1, sondern auf Objekt2. Dies kann jetzt unabhängig von Objekt1 geändert werden. Nach Beendigung von malzwei() wird es nicht mehr gebraucht und automatisch gelöscht. Objekt1 bleibt davon unberührt.Abbildung 135 Veränderung an einer Kopie des FunktionsargumentsIm Fall des Aufrufs von change_list() im zweiten Beispiel sieht das anders aus. Da ein Objekt vom Typ list grundsätzlich veränderbar (mutable) ist, erzeugt der Interpreter keine Kopie. Alle Veränderungen am Parameter in der Funktion werden am Originalobjekt durchgeführt.Abbildung 136 Veränderung am OriginalobjektWenn einer Funktion in einer Programmiersprache eine Variable als Argument übergeben wird, werden in der Fachsprache zwei Mechanismen der Übergabe unterschieden:• Wertübergabe ( Call-by-Value ). Nur der Wert der Variable wird übergeben, es findet also eine Kopie statt und nur diese Kopie wird in der Funktion verändert.• Referenzübergabe ( Call-by-Reference ). Ein Verweis auf ein Objekt wird übergeben. Veränderungen am Wert der Variablen innerhalb der Funktion wirken sich dauerhaft auf den Inhalt dieses Objekts aus.Die Parameterübergabe in Python passt nicht recht zu einem dieser beiden Mechanismen. Python übergibt Argumente zunächst immer nach dem Prinzip Call by Reference. Abhängig davon, ob die Variable einen Datentyp hat, der mutable oder immutable und davon, ob in der Funktion der Wert des Arguments geändert wird, verfährt der Interpreter folgendermassen:• Argumente, die mutable sind, werden ähnlich dem Prinzip Call-by-Reference übergeben, Ihr Wert kann durch die Funktion dauerhaft verändert werden.• Argumente, die immutable sind und deren Wert in der Funktion nicht verändert wird, werden ähnlich dem Prinzip Call-by-Reference übergeben• Argumente, die immutable sind und deren Wert in der Funktion verändert wird, werden zunächst ähnlich wie bei Call by Reference übergeben, aber vor Änderungen kopiert. Die Übergabe wird also im Endeffekt nach dem Prinzip Call-by-Value ausgeführt.Einige Autoren empfehlen deswegen, die Art der Wertübergabe in Python als «Call-by-Object» oder «Call-by-Object-Reference» zu nennen. Aber unabhängig davon, wie Sie es nennen – Wichtiger ist es zu verstehen, was der Effekt auf den Wert einer Variablen in verschiedenen Situationen ist.13.11 Seiteneffekte und Programmierstil.Eine Funktion in der Mathematik hat Parameter (Das sind die Inputs) und ein Ergebnis (Das ist der Output). Funktionen in Programmiersprachen haben möglicherweise ein Ergebnis (Der Rückgabewert) und zusätzlich allfällige Seiteneffekte. Zwei Beispiele dafür sind:• Die eingebaute Funktion max(wert1, wert2) hat ein Ergebnis, nämlich die Rückgabe des grösseren der beiden Werte. Sie hat keine Seiteneffekte.• Die eingebaute Funktion print() hat kein Ergebnis, sondern ausschliesslich einen Seiteneffekt, nämlich die Ausgabe von Text auf den Bildschirm.In diesem Kapitel haben Sie gesehen, dass eine Funktion sowohl ein Ergebnis wie auch Seiteneffekte haben kann, zum Beispiel:1) Eine Funktion macht Ausgaben und gibt einen Wert zurück2) Eine Funktion liest Eingaben und gibt einen Wert zurück3) Eine Funktion ändert den Inhalt von globalen Variablen durch Deklaration einer Variablen als global und anschliessender Veränderung des Werts dieser Variablen in der Funktion4) Eine Funktion bekommt eineien Variable Argument übergeben, dessen Typ mutable ist und sie verändert den Wert dieses Arguments permanent, das heisst der Wert ist nach dem Aufruf der Funktion ein anderer.Die Seiteneffekte bei 3) und 4) sind problematisch, da dadurch in grösseren Programmen die Übersicht darüber verloren gehen kann, an welchen Stellen der Wert einer globalen Variablen oder der Inhalt einer Liste verändert wird. Das führt möglicherweise zu schwer zu findenden Fehlern. Es ist ein schlechter Programmierstil, wenn Sie in Funktionen solche Seiteneffekte einbauen. Es ist ein guter Programmierstil, solche Seiteneffekte zu vermeiden. Dazu einige Tipps:• Sie sollten möglichst nur den Rückgabewert einer Funktion verwenden, um das gewünschte Resultat zu erreichen. Argumente sollten möglichst nur als Input dienen und nicht als weiterer Output.• Verwenden Sie globale Variablen generell sparsam• Wenn Sie den Wert einer globalen Variablen verändern müssen, tun Sie das im Hauptprogramm und nicht versteckt in einer Funktion oder (noch schlechter!) in verschiedenen Funktionen.• Wenn Sie in einer Funktion eine Liste verarbeiten müssen, übergeben Sie der Funktion eine Kopie der Liste und nicht das Original. Das geht am einfachsten mit einem Slice:kopie_liste = original_liste[:]myfunction(kopie_liste)13.12 ZusammenfassungIn diesem Kapitel haben Sie sehr viele grundlegende Informationen zu Funktionen erhalten. Damit Sind sie ab jetzt in der Lage, auch grössere Programme zu schreiben, diese übersichtlich zu strukturieren und allem mehrfach verwendeten Code in Funktionen zusammenzufassen. Eine kurze Zusammenfassung der wichtigsten Informationen aus diesem Kapitel ist:• Eine Funktion ist ein Stück Programmcode mit einem Namen. Sie können eine neue Funktion definieren und anschliessend mit ihrem Namen aufrufen.• Die Definition der Funktion muss im Programm vor dem ersten Aufruf der Funktion stehen• Funktionen können optional Parameter verarbeiten. Beim Aufruf einer Funktion werden Argumente, z.B. Literale oder Variablen an eine Funktion übergeben. Dies erfolgt in der Form funktionsname( Argument1, Argument2, … )• Viele Funktionen haben eine feste Anzahl von Parametern. Die Anzahl der Argumente beim Aufruf muss dann gleich sein.• Python prüft nicht, ob der Datentyp von Argumenten korrekt ist. Das liegt allein in der Verantwortung des Programmierers.• Funktionen haben einen optionalen Rückgabewert, der an eine Variable zugewiesen werden kann. Dies erfolgt in der FormVariable = ( Argument1, Argument2, … )• Der Rückgabewert einer Funktion kann als Argument einer anderen Funktion benutzt werden, beispielsweise:Variable = funktion1(  funktion2( Argument1, Argument2, …) )• Ist der Rückgabewert entweder True oder False, können Funktionsaufrufe auch in Bedingungen verwendet werden, z.B. in einer if-Bedingung:If funktionsname( Literal, Variable, Variable, Literal, … ) :• Variablen, die innerhalb einer Funktion definiert werden, sind lokal. Das heisst, sie gelten nur in dieser Funktion.• Variablen, die im Hauptprogramm definiert wurden, sind auch innerhalb von Funktionen gültig. Sie können innerhalb der Funktion lesend auf den Wert der Variablen zugreifen.• Wenn es eine lokale und eine globale Variable mit dem gleichen Namen gibt, hat innerhalb der Funktion die lokale Variable Vorrang• Wenn eine globale Variable in einer Funktion mit dem Zusatz global deklariert wird, kann ihr Wert auch innerhalb der Funktion verändert werden• Wird eine Variable als Argument an eine Funktion übergeben, die einen immutablen Datentyp wie z.B. int, float oder str hat, dann kann der Inhalt der Variablen in der Funktion zwar verändert werden, aber nicht dauerhaft. Der Inhalt der Variablen ist nach Beendigung der Funktion wieder der gleiche wie vor dem Funktionsaufruf.• Wird eine Variable als Argument an eine Funktion übergeben, die einen mutablen Datentyp wie z.B. list hat, dann kann der Inhalt der Variablen in der Funktion dauerhaft verändert werden, dass heisst, die Änderungen bestehen auch nach Beendigung der Funktion fort.Weitere Informationen zu Funktionen und Modulen finden Sie im Kapitel 1613.13 AufgabenSchreiben Sie die folgenden Funktionen und sammeln Sie in einer Datei myfuctions.py1) Erzeugen sie eine Funktion is_int( instring: str) -> bool, die den Wert True zurückgibt, wenn das Argument instring in eine ganze Zahl umgewandelt werden kann.2) Erzeugen sie eine Funktion is_float( instring: str) -> bool, die den Wert True zurückgibt, wenn das Argument instring in eine Flieskomma-Zahl umgewandelt werden kann.3) Erzeugen Sie eine Funktion summe( zahlenliste: list ) -> int, die eine Liste von ganzen Zahlen übergeben bekommt und die Summe ausgibt. Falls die Liste Elemente enthält, die keine ganzen Zahlen sind, sollen diese einfach ignoriert werden.4) Erzeugen Sie eine Funktion mittel( zahlenliste: list ) -> float, die eine Liste von ganzen Zahlen und Fliesskommazahlen übergeben bekommt und deren Mittelwert ausgibt. Falls die Liste Elemente enthält, die keine ganzen Zahlen sind, sollen diese einfach ignoriert werden. Die Funktion soll auch dann funktionieren, wenn die Liste nur eine Zahl enthält.5) Testen Sie Ihre Funktionen in der REPL, nachdem sie dort myfunctions importiert haben6) Schreiben Sie ein testprogram test_functions.py, mit dem Sie ihre Funktionen importieren und mit verschiedenen Argumenten testen14 Weitere DatenstrukturenSie kennen bisher einfache Datentypen wie int, float oder bool sowie die Aufzählungstypen list und str. In diesem Kapitel geht es um weitere Datenstrukturen, die man gemeinsam mit Listen als Sammlungen (Collections) bezeichnet. Sie erlauben es Ihnen, in Ihren Programmen auch komplexere Sachverhalte als bisher abzubilden.14.1 LernzieleNach der Bearbeitung dieses Kapitels können Sie:• Die Eigenschaften von Tupeln beschreiben und sie in Ihren Programmen verwenden• Die Eigenschaften von Sets beschreiben und sie in Ihren Programmen verwenden• Die Eigenschaften von Dictionaries beschreiben und sie in Ihren Programmen verwenden14.2 TupelTupel haben einige Gemeinsamkeiten mit Listen. Wie Listen und Strings sind sind Tupel Aufzählungen, dass heisst sie enthalten beliebig viele Elemente, die von beliebigen Datentypen sein können und diese Elemente haben eine festgelegte Reihenfolge. Ein Tupel wird definiert mit einer Aufzählung von Werten in runden Klammern oder als Auflistung ohne Klammern:>>> tupel1 = (1, 9, 'Hallo', True, 12.33 )>>> tupel1(1, 9, 'Hallo', True, 12.33 )>>> tupel2 = 'A', 'B', 'C'>>> tupel2('A', 'B', 'C')>>>Ein leeres Tupel kann nur mit runden Klammern erzeugt werden und um ein Tupel mit nur einem Element zu erzeugen, muss als spezielle Eigenart nach dem einzigen Element ein Komma gesetzt werden!>>> tupel3 = ()>>> tupel3()>>> tupel4 = 1,>>> tupel4(1,)>>> tupel4 = (1,)>>> tupel4(1,)
Auf die Elemente eins Tupels kann wie bei Listen mit einem Index in eckigen Klammern zugegriffen werden, der bei 0 beginnt:tupel = (1, 9, 'Hallo', True, 12.33 )>>> tupel[1]9>>> tupel[2]'Hallo'>>> tupel[3]TrueSie können Slices von Tupeln erzeugen:>>> tupel[2:4]('Hallo', True)Sie können mit in feststellen ob ein bestimmter Wert ein Element eines Tupels ist:>>> 12.33 in tupelTrue>>> 13 in tupelFalse>>>Für Tupel funktionieren viele der Funktionen und Methoden, die auch für Listen und Strings verfügbar sind, z.B.:>>> len(tupel)5Tupel sind iterable, d.h. auf die Elemente Tupel können Sie mit einer Schleife nacheinander zugreifen:>>> for element in tupel:...     print(element)... 19HalloTrue12.33Und nun zum grossen Unterschied zu Listen: Im Gegensatz zu Listen können Tupel nicht verändert werden!>>> tupel[1] = 300Traceback (most recent call last):  File "<stdin>", line 1, in <module>TypeError: 'tuple' object does not support item assignmentWozu sind Tupel denn gut, wenn sie einerseits viele Gemeinsamkeiten mit Listen haben, nur dass die Einschränkung besteht, dass sie nach der Erzeugung nicht mehr verändert werden können?• Die Unveränderbarkeit von Tupeln kann auch ein Vorteil sein, wenn man eine Aufzählung beliebiger Elemente benötigt, sich aber nicht darum sorgen möchte, ob diese Aufzählung unbeabsichtigt verändert wird, wie das zum Beispiel bei der Übergabe einer Liste an eine Funktion geschehen kann. Durch die Verwendung von Tupeln können Sie sicherstellen, dass Sie nicht unbeabsichtigt Seiteneffekte in Ihren Code einbauen, die durch die Verwendung von Datenstrukturen, die mutable sind auftreten können.• Ein anderer Aspekt ist, das Tupel immer dann sinnvoll angewendet werden können, wenn eine Veränderung von Inhalten nicht nötig ist, etwa bei einer Festlegung einer zulässigen Wertemenge für einen Status, z.B.: ( ‘geplant’, ‘in Arbeit’, ‘fertig’, ‘abgebrochen’ ). Eine Änderung ist dann meistens gar nicht erwünscht. Wenn es dann doch nötig ist, eine Änderung zu machen, ist ein Tupel auch schnell in eine Liste umgewandelt und umgekehrt:>>> tupel = (1, 9, 'Hallo', True, 12.33 )>>> list(tupel)[1, 9, 'Hallo', True, 12.33]>>> liste = list(tupel)>>> liste[2] = 10>>> tupel = tuple(liste)>>> tupel(1, 9, 10, True, 12.33)• Sehr grosse Tupel werden von Python viel schneller verarbeitet als sehr grosse Listen. Wird eine Änderbarkeit nicht benötigt und ist die Geschwindigkeit der Programmausführung wichtig, sollten Sie also Tupel den Listen vorziehen. 14.3 SetsSet ist der Python-Datentyp für Mengen. Eine Menge ist im Gegensatz zu Listen, Strings und Tupeln eine ungeordnete Sammlung. Wie in den Mengen der Mathematik gibt es in Sets keine doppelte Elemente. Diese Eigenschaft von Sets wird oft ausgenutzt, um Duplikate zu vermeiden oder zu beseitigen.Die typischen Dinge, die mit Mengen in der Mathematik gemacht werden sind: Aussagen machen, ob ein Element in einer Menge vorkommt sowie die Bildung von Vereinigungsmengen, Schnittmengen, und Differenzmengen. All dies funktioniert auch mit Sets in Python.Ein Set wird mit Literalen in geschweiften Klammern oder durch die Anwendung der Funktion set() auf einen Aufzählung (Liste, String) erzeugt. Duplikate werden dabei ausgeschieden und die Reihenfolge ist ungeordnet:>>> set1 = { 'Brot', 'Käse', 'Kuchen', 'Brot' }>>> set1{'Brot', 'Kuchen', 'Käse'}>>> set2 = set('Dampfschifffahrtsgesellschaft')>>> set2{'f', 'l', 'h', 's', 'c', 't', 'm', 'e', 'g', 'D', 'a', 'r', 'p', 'i'}Um eine leere Menge zu erzeugen muss man set() benutzen, eine Schreibweise mit {} ist nicht möglich. Letzteres erzeugt ein leeres Dictionary, eine Datenstruktur, die Sie im nächsten Abschnitt kennenlernen werden.Eine Prüfung, ob ein Element im Set enthalten ist, kann mit in erfolgen:>>> 'D' in set3True>>> 'X' in set3False>>>>>> 'X' not in set3True>>>Die folgenden Mengenoperationen können wahlweise mit Methoden und Operatoren durchgeführt werden, die Ihnen zum Teil bekannt sind. Für Mengen haben Sie aber eine andere Bedeutung als für Zahlen. Die Beispiele gehen von den folgenden Mengen aus:>>> set1 = {'b', 'c', 'a', 'r', 'd'}>>> set2 = {'l', 'c', 'm', 'a', 'z'}Differenzmenge von set1 und set2>>> set1.difference(set2){'d', 'b', 'r'}>>> set1 - set2 {'r', 'b', 'd'}Vereinigungsmenge von set1 und set2>>> set1.union(set2){'z', 'l', 'd', 'a', 'c', 'b', 'r', 'm'}>>> set1 | set2 {'l', 'b', 'c', 'm', 'a', 'r', 'z', 'd'}Schnittmenge von set1 und set2>>> set1.intersection(set2){'a', 'c'}>>> set1 & set2 {'c', 'a'}Ist set3 Teilmenge von set1?>>> set3.issubset(set1)True>>> set3 <= set1TrueWelche Elemente kommen entweder nur in set1 oder nur in set2 vor?>>> set1 ^ set2 {'l', 'r', 'b', 'z', 'm', 'd'}>>> set1.symmetric_difference(set2){'d', 'z', 'b', 'l', 'r', 'm'}Hat set1 keine Elemente, die auch in set2 sind (d.h. ist die Schnittmenge leer)?>>> set4 = { 'w', 'q', 'y' }>>> set1.isdisjoint(set4)True>>> set1 != set4TrueSets können mit verschiedenen Funktionen und Methoden erzeugt, untersucht und bearbeitet werden. Ein leeres Set kann nicht mit menge = {} erzeugt werden. Sie müssen dafür die Funktion set() verwenden:set1 = set()Die Methode set.add() fügt ein Element zur Menge hinzu>>> set1.add('foo')>>> set1.add('50')>>> set1{'foo', 50}Die Methode  set.remove(50) entfernt ein Element>>> set1.remove(50)>>> set1{'foo'}Die Anzahl der Elemente kann wie bei Strings, Listen oder Tupeln mit len() ermittelt werden:set1 = {50, 99, 12}>>> len(set1)3Die Methode set.copy() erzeugt wie bei Listen eine einfache Kopie der Menge: >>> set2 = set1.copy()>>> set2{50, 99, 12}Sets sind wie Listen und tupel iterable, d.h. auf die Elemente einer Menge können Sie mit einer Schleife nacheinander zugreifen:>>> set1 = {50, 99, 12}>>> for i in set1:...     print(100 - i)... 5018814.4 DictionariesDie wörtliche Übersetzung von «Dictionary» ist Wörterbuch und ein einfaches Wörterbuch enthält jeweils ein Wort in der einen Sprache und die Übersetzung in die andere:DeutschEnglischBrotbreadKäsecheeseMilchmilkEin Dictionary in Python ist eine Datenstruktur, die beliebig viele Paare mit je einem Schlüssel und einem Wert enthalten kann. Das Wörterbuch Deutsch/Englisch könnte damit folgendermassen abgebildet werden:>>> de_to_en = {'Brot': 'bread', 'Käse': 'cheese', 'Milch': 'milk'}Der Deutsche Begriff ist hier der Schlüssel, der englische Begriff der Wert. Mit der Angabe des Schlüssels in eckigen Klammern kann nun der dazugehörige Wert im Dictionary gefunden werden.>>> de_to_en['Käse']'cheese'Ist der gesuchte Schlüssel nicht vorhanden, gibt es einen KeyError:>>> de_to_en['Sülze']Traceback (most recent call last):  File "<stdin>", line 1, in <module>KeyError: 'Sülze'Will man das vermeiden, kann zuerst mit in festgestellt werden, ob ein Schlüssel vorhanden ist:>>> if 'Sülze' in de_to_en:...     de_to_en['Sülze']... >>> if 'Brot' in de_to_en:...     de_to_en['Brot']... 'bread'>>>Weitere Schlüssel/Wert-Paare können einem Dictionary hinzugefügt werden:>>> de_to_en['Sülze'] = 'spam'>>> de_to_en{'Brot': 'bread', 'Käse': 'cheese', 'Milch': 'milk', 'Sülze': 'spam'}Wird ein bereits bestehender Schlüssel benutzt, wird der dazugehörige Wert überschrieben:>>> de_to_en['Käse'] = 'blue stilton'>>> de_to_en{'Brot': 'bread', 'Käse': 'blue stilton', 'Milch': 'milk', 'Sülze': 'spam'}>>>Die Elemente eines Dictionary sind nicht wie bei Listen nummeriert, auf sie kann nur über einen Schlüssel zugegriffen werden. Der Schlüssel muss dabei kein String sein, alle unveränderlichen (immutable) Datentypen können als Schlüssel verwendet werden (Also z.B. str, int, float und tuple). Die Typen der Schlüssel und Werte können beliebig gemischt werden:>>> mixed = { 67 : 'Siebenundsechzig', 'pi' : 3.14, 2.5 : '5 durch 2' }>>> mixed{67: 'Siebenundsechzig', 'pi': 3.14, 2.5: '5 durch 2'}>>>Aus den bisherigen Beispielen ergibt sich:• Dictionaries sind änderbar (mutable)• Ein Schlüssel kann in einem Dictionary nur einmal vorkommen• Die Reihenfolge der Elemente ist anders als bei Listen, Tupeln oder Strings je nach Version nicht festgelegt (unordered) oder sie folgt der Reihenfolge der Einfügung (ab Version 3.6 sind Dictionaries ordered). Verlassen Sie sich bitte nicht darauf – auch wenn Sie mit einer Version >= 3.6 entwickeln, könnte Ihr Programm mit einer älteren Version ausgeführt werden!14.5 Iteration über DictionariesDer Datentyp dict ist iterable, deswegen kann man über ein Dictionary mit einer for-Schleife iterieren. Die folgende Schleife gibt die Schüssel aus:>>> de_to_en{'Brot': 'bread', 'Käse': 'cheese’, 'Milch': 'milk', 'Sülze': 'spam'}>>> for key in de_to_en:...     print(key)... BrotKäseMilchSülzeMöchte man in der Schleife den jeweiligen Wert benutzen, geht das mit dict[key]:>>> for key in de_to_en:...     print( key, ‘heisst auf Englisch’, de_to_en[key] )... Brot heisst auf Englisch breadKäse heisst auf Englisch cheeseMilch heisst auf Englisch milkSülze heisst auf Englisch spam14.6 Methoden, Operationen und Funktionen für DictionariesMit dictionary.pop(key) entfernt man das Element mit dem Schlüssel key aus dem Dictionary und gibt den Wert des Elements zurück:>>> kosten = { 'reisen' : 5000, 'essen' : 10000, 'sparen' : 4500 }>>> entfernt = kosten.pop('sparen')>>> kosten{'reisen': 5000, 'essen': 10000}>>> entfernt4500Mit dictionary.clear() werden alle Elemente gelöschtEine einfache Kopie eines Dictionary wird mit dictionary.copy() erzeugt. Der Rückgabewert ist ein neues Dictionary mit identischem Inhalt.Mit dictionary.items() erhält man eine sogenannte View aller Schlüssel / Wert -Paare. Diese sind als dann als einzelne Tupel verfübar.>>> kosten = { 'reisen' : 5000, 'essen' : 10000, 'sparen' : 4500 }>>> for k in kosten.items():...     print(k)... ('reisen', 5000)('essen', 10000)('sparen', 4500)Mit dictionary.keys() erhält man eine sogenannte View aller Schlüssel>>> for i in kosten.keys():...     print(i)... reisenessensparenMit dictionary.values() erhält man eine sogenannte View aller WerteWarum nennt man das, was diese Methoden liefern View? Der Grund ist, dass hier eine Momentaufnahme des Dictionary «fotografiert» wird. Verändert man das Dictionary, bleibt die View erhalten:>>> kosten_view = kosten.items()>>> kosten_viewdict_items([('reisen', 5000), ('essen', 10000), ('sparen', 4500)])>>> del kosten['reisen']>>> kosten{'essen': 10000, 'sparen': 4500}>>> kosten_viewdict_items([('essen', 10000), ('sparen', 4500)])14.7 Verschachtelte DictionariesMit Dictionaries können Sie nicht nur Schlüssel/Wert-Paare, sondern auch beliebig komplexe Datenstrukturen aufbauen. Als Beispiel dafür dient eine Tabelle von Studierenden mit einer Matrikelnummer, einem Namen, einem Vornamen und einem Studiengang. Die Matrikelnummer soll die Person eindeutig identifizieren, da Namen mehrfach vorkommen können:Nr.NameVornameStudiengang1001SommerSusiChemie1002WinterWalterBWL1078SommerSusiInformatikEin verschachteltes Dictionary wird angelegt, in dem die Nr. der Schlüssel ist und der Wert ein weiteres Dictionary, das die übrigen Informationen enthält:>>> students = { 1001 : {'Name' : 'Sommer', 'Vorname' : 'Susi', 'Studiengang' : 'Chemie' } }>>> students[1001]{'Name': 'Sommer', 'Vorname': 'Susi', 'Studiengang': 'Chemie'}Nun werden weitere Studierende hinzugefügt:>>> students[1002] = {'Name' : 'Winter', 'Vorname' : 'Walter', 'Studiengang' : 'BWL'}>>> students[1078] = {'Name' : 'Sommer', 'Vorname' : 'Susi', 'Studiengang' : 'Informatik' }>>> students{1001: {'Name': 'Sommer', 'Vorname': 'Susi', 'Studiengang': 'Chemie'}, 1002: {'Name': 'Winter', 'Vorname': 'Walter', 'Studiengang': 'BWL'}, 1078: {'Name': 'Sommer', 'Vorname': 'Susi', 'Studiengang': 'Informatik'} }Diese Ausgabe der Tabelle students ist nicht besonders gut lesbar. Deshalb importieren wir die Funktion pprint aus dem Modul pprint, das Teil der Standardbibliothek ist. Der Name steht für «Pretty Print» und damit kann man Datenstrukturen formatiert ausgeben:>>> from pprint import pprint>>> pprint(students){1001: {'Studiengang': 'Chemie', 'Name': 'Sommer', 'Vorname': 'Susi'}, 1002: {'Studiengang': 'BWL', 'Name': 'Winter', 'Vorname': 'Walter'}, 1078: {'Studiengang': 'Informatik', 'Name': 'Sommer', 'Vorname': 'Susi'}}Die folgende Abbildung zeigt das Prinzip, nach dem diese Struktur aufgebaut wurde:Abbildung 141 Einfach verschachteltes DictionaryNun sind gezielte Zugriffe auf die Daten in der folgenden Art möglich:>>> students[1002]['Name']'Winter'>>> students[1002]['Studiengang']'BWL'>>>>>> students[1002]['Studiengang']='Jura'>>> students[1002]{'Name': 'Winter', 'Vorname': 'Walter', 'Studiengang': 'Jura'}Die Studierenden legen in verschiedenen Fächern Prüfungen ab und bekommen dafür Noten. Da es in jedem Studiengang verschiedene Fächer gibt, eignet sich für die Erfassung der Noten wiederum ein Dictionary:>>> students[1001]['Noten']= { 'Anorganik' : 4 }Hier wurde der neue Schlüssel ‘Noten’ erzeugt. Der Wert für diesen Schlüssel ist wieder ein Dictionary, das seinerseits einen neuen Schlüssel ‘Anorganik’ mit dem Wert 4 zugewiesen bekommt.Nun können diesem inneren Dictionary weitere Fachnoten hinzugefügt werden:>>> students[1001]['Noten']['Physik'] = 3>>> students[1001]['Noten']['Organik'] = 5Das gleiche Vorgehen wird für einen weiteren Studierenden durchgeführt; Zuerst wird ein neuer Schlüssel ‘Noten’ mit einem Wert vom Typ Dictionary angelegt, dann können weitere Schlüssel/Wert Paare in dieses Dictionary aufgenommen werden. Mit pprint sieht man den Effekt recht gut:>>> students[1002]['Noten'] = { 'VWL' : 4 }>>> students[1002]['Noten']['BWL'] = 5>>> students[1002]['Noten']['Statistik'] = 3>>> students[1002]['Noten']['Buchhaltung'] = 3>>> pprint(students){1001: {'Studiengang': 'Chemie',        'Name': 'Sommer',        'Noten': {'Anorganik': 4, 'Organik': 5, 'Physik': 3},        'Vorname': 'Susi'}, 1002: {'Studiengang': 'Jura',        'Name': 'Winter',        'Noten': {'BWL': 5, 'Buchhaltung': 3, 'Statistik': 3, 'VWL': 4},        'Vorname': 'Walter'}, 1078: {' Studiengang ': 'Informatik', 'Name': 'Sommer', 'Vorname': 'Susi'}}Die folgende Abbildung verdeutlicht das Prinzip:Abbildung 142 Doppelt verschachteltes DictionarySie können Ihre Dictionaries beliebig tief verschachteln. Das heisst: Die Datenstrukturen in Ihren Programmen können so komplex sein, wie Sie es wollen.14.8 Listen, Tupel und Dictionaries kombinierenEine Liste kann beliebige Objekte enthalten. Bisher haben Sie nur Listen mit Strings oder Zahlen benutzt, aber natürlich können in Listen auch andere Objekte enthalten, zum Beispiel weitere Listen oder Tupel. Im Folgenden Beispiel sehen Sie eine äussere Liste, die weitere Listen als Elemente hat. Der Zugriff auf die Elemente der inneren Listen erfolgt mit [index der äusseren Liste][Index der inneren Liste]:>>> listen_liste = [ [1, 2, 3], ['a', 'b', 'c'], [True, False] ]>>> listen_liste[0][1]2>>> listen_liste[1][0]'a'>>> listen_liste[2][1]False>>>Im folgenden Beispiel sehen Sie eine Liste, die als Elemente drei 2er-Tupel enthält:>>> laender_kennzeichen[('A', 'Österreich'), ('CH', 'Schweiz'), ('D', 'Deutschland')]Diese Struktur kann mit der Funktion dict() in ein Dictionary umgewandelt werden.>>> laender_dict = dict(laender_kennzeichen)>>> laender_dict{'A': 'Österreich', 'CH': 'Schweiz', 'D': 'Deutschland'}>>> laender_dict['D']'DeutschZwei Listen können mit zip() im «Reissverschlussverfahren» zu einem sogenannten zip-Objekt kombiniert werden. Ein Solches Objekt liefert Paare von zwei Werten aus diesen Listen, so ähnlich wie ein range-Objekt eine Reihe von Werten liefert (siehe Kapitel 10.2).>>> kennzeichen = [ 'A', 'CH', 'D' ]>>> laender = [ 'Österreich', 'Schweiz', 'Deutschland' ]>>> for tupel in zip(kennzeichen, laender):...     print(tupel)... ('A', 'Österreich')('CH', 'Schweiz')('D', 'Deutschland')Das zip-Objekt kann auch direkt mit der Funktion dict() in ein Dictionary umgewandelt werden. Im Folgenden Beispiel geschieht das mit den Listen kennzeichen und ländern:>>> laender_dict = dict( zip( kennzeichen, laender ) )>>> laender_dict{'A': 'Österreich', 'CH': 'Schweiz', 'D': 'Deutschland'}>>> laender_dict['CH']'Schweiz'Ein Tupel ist zwar grundsätzlich immutable, es kann aber Listen als Elemente enthalten, die ja selbst wieder mutable sind:>>> tup = ( [1, 2, 3], ['a', 'b', 'c'], [True, False] )>>> tup[0][1, 2, 3]>>> tup[0][1] = 42>>> tup[0][1, 42, 3]Das letzte Beispiel zeigt eine Liste von Dictionaries:>>> artikel = [ {'Schuhcreme braun' : 2.99}, ... {'Schuhcreme schwarz' : 2.99},... {'Schnürsenkel 40cm, braun' : 1.54 }, ... {'Schnürsenkel 60cm, schwarz' : 2.10 } ]>>> artikel[1]{'Schuhcreme schwarz': 2.99}14.9 Flache und tiefe KopienIn Kapitel 9 haben Sie gesehen, dass eine Zuweisung einer Variablen mit einem änderbaren (mutable) Datentyp an eine andere Variable lediglich eine weitere Referenz auf ein und dasselbe Objekt erzeugt. Sie haben dort auch die Funktion copy() kennengelernt, mit der Sie eine vom Original unabhängige Kopie erzeugen können.Die Methode copy() gibt es für alle Datentypen, die mutable sind, also beispielsweise:list.copy()set.copy()dict.copy()Wie verhält sich copy(), wenn die Elemente einer Liste wieder Listen, Tupel, Sets oder Dictionaries sind? Im folgenden Beispiel gehen wir von einer Liste aus, die wieder eine Liste als Element enthält und erzeugen eine Kopie davon:>>> original = [ 'Brot', 'Käse', [ 1, 2, 3 ] ]>>> kopie = original.copy()>>> kopie[1]'Käse'Wird nun das zweite Element der Liste im original verändert, bleibt der Inhalt der Kopie davon unbeeinflusst:>>> original[1] = 'Milch'>>> kopie[1]'Käse'Anders sieht es bei einer Änderung des Originals innerhalb der Liste mit den Zahlen aus:>>> original[2][1] = 42>>> kopie[2][1] 42Mit copy() erhalten Sie lediglich eine sogenannte flache Kopie eines Objekts. Flach bedeutet in diesem Zusammenhang, dass nur die erste Ebene des Objekts kopiert wird. Die zweite Ebene (In unserem Beispiel das Listen-Element am Ende) wird nicht kopiert. Die kopierte Liste enthält die Verweise auf das gleiche Listen-Objekt wie das Original. Die folgende Abbildung zeigt, was nach der Kopie passiert:Abbildung 143 Zwei Listen nach copy()Die Situation nach den Änderungen des Originals sieht fogendermassen aus:Abbildung 144 Änderungen am Original nach flacher KopieWenn Sie auch verschachtelte Datenstrukturen kopieren wollen, müssen Sie die Funktion deepcopy() aus dem Modul copy benutzen. Sie erzeugt eine sogenannte tiefe Kopie. Tief bedeutet in diesem Zusammenhang, dass auch von verschachtelten Datenstrukturen eine komplette Kopie erzeugt wird:>>> from copy import deepcopy>>> original = [ 'Brot', 'Käse', [ 1, 2, 3 ] ]>>> kopie = deepcopy(original)>>> original[2][1] = 42>>> original['Brot', 'Milch', [1, 42, 3]]>>> kopie['Brot', 'Käse', [1, 2, 3]]Die folgenden Abbildungen zeigen den Unterschied bei der Verwendung von copy() und deepcopy()Abbildung 145 Änderungen am Original mit tiefer KopieDie Funktion deepcopy() kann nicht nur für Datenstrukturen mit verschachtelten Listen verwendet werden, sondern für alle verschachtelten Datenstrukturen, die mutable sind. Die Struktur students aus dem Kapitel 14.7 mit ihren verschachtelten Dictionaries könnten Sie mit deepcopy() ebenfalls komplett kopieren (Probieren Sie das doch einmal aus!).14.10 ZusammenfassungSie kennen jetzt die wesentlichen Sammlungs-Typen von Python (also solche, bei denen ein Objekt mehr als einen Wert speichern kann). Die folgende Tabelle fasst die wichtigsten Eigenschaften dieser Datentypen zusammen:TypElemente vom TypAufzählbar(iterable)?Geordnete Reihenfolge (ordered)?Änderbar(mutable)?Duplikate erlaubt?strstrJaJaNeinJatuplebeliebigJaJaNeinJalistbeliebigJaJaJaJasetbeliebigJaNeinJaNeindictSchlüssel:immutable TypWert:beliebigJaVersion3.6:JaJaSchlüssel:NeinWert:JaWeitere wichtige Erkenntnisse sind:• Tupel verhalten sich in vielerlei Hinsicht wie Listen, sind aber immutable. Sie sollten immer dann Tupel statt Listen verwenden, wenn es nicht auf die Änderbarkeit ankommt, weil Ihr Code dadurch sicherer und effizienter wird.• Sets eignen sich besonders für Aufgaben, in denen es darauf ankommt, dass in Sammlungen von Daten keine Duplikate vorkommen. Sie können zum Beispiel mit set(liste) alle mehrfach vorkommenden Werte entfernen. Sehr mächtig sind auch die Mengenoperationen, die Sie mit Sets durchführen können.• Dictionaries erlauben Ihnen, auf Daten mit einem Schlüsselbegriff statt mit einem Index zuzugreifen. Sie sind damit sehr gut geeignet, um bei typischen Programmieraufgaben komplexe Objekte darzustellen, wie etwa Kunden, Artikel oder Adressen.• Die verschiedenen Arten von Sammlungen (Listen, Tupel, Sets und Dictionaries) können kombiniert und beliebig tief verschachtelt werden. Sie können damit selber aus wenigen einfachen Datenstrukturen beliebig komplexe Datenstrukturen erzeugen, ganz so wie Ihre Programme es erfordern. • Eine Eigenheit von Python ist das Verhalten der Methode copy(), die nur flache Kopien erzeugen kann. Für vollständige Kopien verschachtelter Datenstrukturen steht Ihnen die Funktion deepcopy() aus dem Modul copy zur Verfügung.Durch Anwendung der in diesem Kapitel vorgestellten Datenstrukturen und Techniken können Sie nun wesentlich mächtigere Programme schreiben. Die folgenden Aufgaben enthalten daher einige umfangreichere Problemstellungen, die schrittweise ausgebaut werden.14.11 Aufgaben1) Können Sie die Programme lottoziehung.py, lotto1.py und. lotto2.py durch den Einsatz von Sets oder Tupeln anstelle von Listen verbessern? Wenn ja, erstellen Sie entsprechende Versionen davon.2) Dies ist eine Übung zu Mengenoperationen. Die folgende Tabelle enthält Informationen zu verschiedenen Sprachen, die als Amtssprache in verschiedenen Ländern gelten.SpracheLänderKürzel LandDeutschDeutschland, Österreich, Schweiz, Luxembourg, LiechtensteinD, A, CH, L, LIItalienischItalien, SchweizI, CHFranzösischFrankreich, Belgien, Luxembourg, SchweizF, B, L, CHEnglischGrossbritannien, USAGB, USFlämischBelgienBRumantschSchweizCHErzeugen Sie für jede Sprache eine gleichnamige Menge, die als Element die Länderkürzel der Länder, in der diese Sprache gesprochen wird enthält, z.B.:Deutsch = { ‘D’, ‘A’, ‘CH’, ‘L’, ‘LI’ }Welche Mengenoperationen sind zur Lösung der folgenden Aufgaben geeignet?1. Erzeugen Sie eine Menge AlleSprachen  aus der Vereinigung der 4 anderen Sprachmengen.2. Gesucht sind die Länder, in denen sowohl Franzoesisch wie auch Deutsch gesprochen wird. 3. Gesucht sind die Länder, in denen Französisch, aber nicht Deutsch gesprochen wird. 4. Gesucht sind die Länder, in denen Deutsch, aber nicht Französisch gesprochen wird. 5. Gesucht sind die Länder, in denen entweder Französisch oder Deutsch gesprochen wird, aber nicht beide Sprachen.6. Gesucht sind die Länder, in denen kein Deutsch gesprochen wird7. Gesucht sind die Länder, in denen weder Italienisch noch Französisch gesprochen wird.3) Eine Firma versendet Medikamente in verschiedene Länder. Ein Python-Programm beipack.py soll dem Versand dabei helfen, dem Produkt alle nötigen Beipackzettel beizulegen. Eingabe ist das Länderkürzel, Ausgabe sind die Sprachen. Lösen Sie diese Aufgabe mit Tupeln und einem Dictionary. Zwei Beispiele:$ python beipack.pyWelches Land? CHDeutschFranzösischItalienischRumantsch$ python beipack.pyWelches Land? IIalienisch15 Dateien verarbeitenBisher haben Sie nur mit Daten gearbeitet, die Sie mit Variablen in Objekten gespeichert haben. Objekte existieren nur im Hauptspeicher und Ihre Daten sind nach Beendigung Ihrer Programme nicht mehr verfügbar. Es wird Zeit, das zu ändern!15.1 LernzieleIn diesem Kapitel lernen Sie, wie sie in Ihren Programmen• Daten aus Dateien lesen können• Daten permanent in Dateien speichern können• Die Anweisung with mit Dateien verwenden können15.2 Dateien mit with und open() lesenDas Programm readfile.py liest die Datei panther.txt, die im gleichen Dateiverzeichnis steht, zeilenweise ein und gibt die gelesenen Zeilen auf den Bildschirm aus:In diesen drei Zeilen passiert eine ganze Menge:• Hinter dem Schlüsselwort with in Zeile 1 steht ein Aufruf der eingebauten Funktion open(). Sie bekommt zwei String-Argumente, einen Dateinamen und ein ‘r’. Letzteres steht für read und erlaubt das Öffnen einer Datei zum Lesen. • Nach dem Aufruf von open steht ‘as in_file’ . Das Schlüsselwort as gehört zur with-Anweisung und datei_objekt repräsentiert die mit open() geöffnete Datei. • Das datei_objekt ist iterable, dass heisst es kann in Zeile 2 mit einer for-Schleife durchlaufen werden. Die einzelnen Elemente, die dabei pro Schleifen-Durchlauf der Variablen zeile zugewiesen werden, sind Strings, die jeweils eine Zeile aus der Datei enthalten. Diese werden in Zeile 3 mit print() ausgegeben. • Die Methode str.rstrip() entfernt dabei überflüssige Leerzeichen und den Zeilenumbruch vom Ende jeder Zeile. • Wenn Die letzte Zeile von datei_objekt gelesen wurde, ist die for-Schleife beendet.15.3 Dateien mit with und open() schreibenDie Funktion open() kann statt mit dem Modus ‘r’ auch mit dem Modus ‘w’ (write) aufgerufen werden. Dann kann in die Datei auch geschrieben werden. Das folgende Programm demonstriert das:Nach der Ausführung des Programms gibt es im aktuellen Dateiverzeichnis eine Datei panther.txt, die den folgenden Inhalt hat:Der Panther (von Robert Gernhard)Der Panther, der PantherErst lag Er, dann stand erworauf Er so erschrakdass Er gleich wieder lagDer Aufruf der methode datei_objekt.write( String ) in Zeile 10 des Programms schreibt je einen String an das Ende der Datei out.txt. Das an den String angehängte ‘\n’ ist das Zeichen für den Zeilenumbruch. Ohne dieses Zeichen würden alle fünf Ausgaben hintereinander in der einzigen Zeile der Datei stehen (Probieren Sie das aus!). Innerhalb einer with-Anweisung können auch mehrere Dateien mit open() geöffnet werden. Das folgende Programm copy_lines.py demonstriert das mit zwei Dateien, von denen die eine zum Lesen (‘r) und die andere zum Schreiben (‘w’) geöffnet wird:Hier werden die Dateinamen abgefragt und anschliessend werden zwei Dateien mit diesen Namen innerhalb einer with-Anweisung mit open() geöffnet. Das Ergebnis sind zwei Dateiobjekte in_file und out_file. Es ist wichtig, den Unterschied zwischen Dateinamen und Dateiobjekt zu beachten; für Schreib- und Lese-Operationen auf Dateien benötigen Sie ein Dateiobjekt und nicht nur den Dateinamen!Das Programm wird im folgenden Beispiel mit den Dateinamen panther.txt und out.txt ausgeführt. $ python copy_lines.pyName der Eingabedatei: panther.txtName der Ausgabedatei: out.txt5 Zeilen in out.txt geschrieben.Danach steht in out.txt das gleiche Gedicht wie in panther.txt.In den bisherigen Beispielen wurde immer davon ausgegangen, dass die Dateien im aktuellen Dateiverzeichnis liegen. Als Dateinamen können Sie aber auch den vollständigen Dateipfad angeben. Ein Beispiel unter Windows könnte so aussehen:$ python copy_lines.pyName der Eingabedatei: C:\Users\Jochen\Downloads\panther.txtName der Ausgabedatei: C:\Users\Jochen\Texte\out.txtEntsprechend unter Mac OSX:$ python copy_lines.pyName der Eingabedatei: /Users/Jochen/Downloads/panther.txtName der Ausgabedatei: /Users/Jochen/Texte/out.txt15.4 Details zu open()An dieser Stelle ist es sinnvoll, einige Details aufzulisten, die Ihnen bei der Benutzung von open() geläufig sein sollten. Für open insgesamt 8 mögliche Parameter, die Sie der Online-Dokumentatition entnehmen können. Für die Lösung Aufgaben in diesem Buch müssen Sie drei davon kennen:open(filename: str, mode='r': str, encoding=None: str) -> dateiobjektDie Bedeutung dieser Parameter und mögliche Werte dafür werden im Folgenden erklärt:Mode:ModusÖffnen der Datei …'r'Zum Lesen'w'Zum Schreiben (Existierende Datei wird überschrieben)'x'Zum Neuanlegen (Fehler, wenn die Datei schon existiert)'a'Zum Schreiben (An eine existiende Datei wird angefügt, ansonsten wird die Datei angelegt)'b'Als Binärdatei 't'Als Textdatei (Standardmodus, wenn der Parameter leer ist'+'Lesen und Schreiben Datei-Arten und der Rückgabewert von open()Es gibt zwei verschiedene Arten von Dateien:• Textdateien enthalten lesbare Zeichen und sind in Zeilen strukturiert. Beispiele dafür sind Python-Programme, mit einfachen Texteditoren erstellte .txt-Dateien sowie als Text abgespeicherte oder exportierte Daten aus Office-Programmen.• Binärdateien enthalten auch nicht lesbare Zeichen und sind nicht in Zeilen strukturiert. Typische Beispiele sind Fotos, Videos, MP3-Musikdateien oder auch Word- und Powerpoint Dokumente.Der Rückgabewert ist ein Datei-Objekt, das die Methoden read() und write() hat. Je nach Modus beim Öffnen gibt es folgende Unterschiede beim Lesen und Schreiben mit diesem Objekt:• Wenn eine Datei im Textmodus geöffnet wurde, ist das Ergebnis einer Leseoperation vom Typ str und wenn in eine im Textmodus geöffnete Datei mit write() geschrieben wird, sollte das Argument von write vom Typ str sein. • Wenn eine Datei im Binärmodus geöffnet wurde, ist das Ergebnis einer Leseoperation vom Typ bytes und wenn in eine im Binärmodus geöffnete Datei mit write() geschrieben wird, sollte das Argument von write in der Regel vom Typ bytes sein.Encoding bei Textdateien:Es gibt für die Darstellung von Texten in Dateien unterschiedliche Zeichensätze wie etwa ASCII, Unicode oder UCS. Gebräuchlich ist vor allem UCS. Für diesen Zeichensatz gibt es verschiede Encodings, deren Bezeichnung mit UTF beginnt. Beispiel dafür sind: UTF-8, UTF-8-sig, UTF-16 , UTF-32. • Für reine Textdateien benötigen Sie diese Angabe nicht, bei einigen anderen Aufgaben, wie dem Import von Daten aus Excel und Datenbanksystemen aber möglicherweise schon. • Wird kein Encoding angegeben, setzt Python das Standard-Encoding für das jeweilige Betriebssystem und dessen Spracheinstellung ein. Das Encoding spielt nur beim Textmodus eine Rolle.Exceptions bei open(), read() oder write()Bei Open kann eine OsException (Betriebssystem-Ausnahme) auftreten. Diese Klasse von Exceptions hat diverse Unterklassen. Für den Umgang mit Dateien von Interesse sind folgede Exceptions:ExceptionBedeutungFileNotFoundErrorDie Datei, deren Name als erster Parameter von open() angegeben wurde, existiert nichtPermissionErrorSie haben keine Berechtigung eine Datei zu öffnen oder auf ein Dateiverzeichnis zuzugreifenIsADirectoryErrorSie versuchen aus einem Dateiverzeichnis zu lesen oder in ein Verzeichnis zu schreibenNotADirectoryErrorDas Verzeichnis, das Sie als Teil des Dateinamens in open() angegeben haben, existiert nichtDiese Ausnahmen führen zu einem Programmabbruch. Daher wollen Sie vielleicht diese Ausnahmen in Ihren Programmen behandeln. 15.5 Ausnahmen behandelnDas Programm copy_lines.py könnte mit einem Dateinamen aufgerufen werden, der nicht existiert. Dann passiert folgendes:$ python copy_lines.pyName der Eingabdedatei: gibtsnicht.txtName der Ausgabedatei: out.txtTraceback (most recent call last):  File "copy_lines.py", line 9, in <module>    with open(in_dname, 'r') as in_file, open(out_dname, 'w') as out_file :FileNotFoundError: [Errno 2] No such file or directory: 'gibtsnicht.txt'Ebenso könnte es passieren, dass Sie kein Leserecht für die Eingabedatei haben, als Ausgabedatei einen nicht existierenden Dateipfad angegeben haben oder im angegebenen Verzeichnis keine Schreibrechte haben. Dateioperationen können also aus mehreren Gründen fehlschlagen und Sie sollten das mit try: und except: abfangen:15.6 Zeilen zu bestehenden Dateien hinzufügenIn den bisherigen Beispielen wurden Dateien mit ‘r’ zum Lesen und mit ‘w’ zum Schreiben geöffnet. Im letzteren Fall wird der bisherige Inhalt der Datei komplett überschrieben. Wenn Sie an eine bestehende Datei etwas anhängen wollen, benutzen Sie ‘a’ (append). Das folgende Programm demonstriert das:Wird es einige Male in grösseren Zeitabständen aufgerufen, hat die Datei out.txt anschliessend den folgenden Inhalt:Geschrieben am 03.06.19 13:05Geschrieben am 03.06.19 13:06Geschrieben am 03.06.19 13:07Geschrieben am 03.06.19 13:08Geschrieben am 03.06.19 13:1215.7 Dateien in Datenstrukturen einlesenEs kommt häufig vor, dass Sie den Inhalt einer Text-Datei in eine interne Datenstruktur, etwa in eine Liste einfügen wollen, um anschliessend mit dem Inhalt dieser Datenstruktur zu arbeiten. Sie könnten natürlich die Datei zeilenweise lesen und Zeile für Zeile mit list.append() an eine Liste anhängen. Es geht aber auch einfacher mit den Methoden readlines() und read() eines Dateiobjekts:>>> with open('/tmp/panther.txt') as in_file :...     gedicht_liste = in_file.readlines()... >>> gedicht_liste['Der Panther (von Robert Gernhard)\n', 'Der Panther, der Panther\n', 'Erst lag er, dann stand er\n', 'worauf er so erschrak,\n', 'dass er gleich wieder lag']Die Anweisung hat, ganz ohne Schleife und weiteren Aufwand aus der Datei eine Liste der einzelnen Zeilen erzeugt. Im Gegensatz zu readlines() erzeugt die Methode read() einen String, der den Inhalt der Datei enthält.>>> with open('/tmp/panther.txt') as in_file :...     gedicht_string = in_file.read()... >>> gedicht_string'Der Panther (von Robert Gernhard)\nDer Panther, der Panther\nErst lag er, dann stand er\nworauf er so erschrak,\ndass er gleich wieder lag'15.8 CSV-DateienEin sehr verbreitetes Format für den Daten-Export und -Import aus Microsoft Excel und aus Datenbanken wie MySQL ist das CSV-Format (Comma Separated Values). Aus einer Excel-Datei exportieren Sie die Zeilen einer Tabelle auf folgende Weise als .csv datei Sie wählen «Datei / Speichern unter» und wählen das Format CSV UTF-8Dadurch wird die Textdatei Adressen.csv erzeugt. Jede Zeile der Tabelle ergibt eine Textzeile und die Spaltenwerte sind durch je ein Semikolon getrennt:Vorname;Name;Telefon;Strasse;Nr.;PLZ;OrtHans;Harrer;043 2112112;Randenstrasse;12;8001;ZürichMaria;Martens;043 9876543;Bahnhofstrasse;10;8703;ErlenbachCarla;Clementi;062 1234567;Rebweg;1a;5000;AarauDas Modul CSV aus der Standardbibliothek erlaubt es Ihnen, dieses Format sehr einfach zu lesen und zu schreiben. Das Modul enthält unter anderem die Funktionen:csv.reader(csvfile, dialect='excel', **fmtparams) # Lesen von .csv-Inhaltencsv.writer(csvfile, dialect='excel', **fmtparams) # Schreiben von .csv-InhaltenDie Funktionen geben ein Objekt zurück, über das mit einer for-Schleife iteriert werden kann. Das folgende Beispiel zeigt was reader() aus unserer Beispiel-Datei Adressen.csv liefert:$ python read_csv.py['Vorname', 'Name', 'Telefon', 'Strasse', 'Nr.', 'PLZ', 'Ort']['Hans', 'Harrer', '043 2112112', 'Randenstrasse', '12', '8001', 'Zürich']['Maria', 'Martens', '043 9876543', 'Bahnhofstrasse', '10', '8703', 'Erlenbach']['Carla', 'Clementi', '062 1234567', 'Rebweg', '1a', '5000', 'Aarau']Beachten Sie die Angabe encoding = ‘UTF-8-sig’ bei open(). Jede Zeile der CSV-Datei wird danach vom reader_objekt als Liste von Strings bereitgestellt, wie Sie an der Ausgabe erkennen können.Um aus einem Python-Programm eine CSV-Datei zu erzeugen, benutzen sie die Funktion writer(). Im folgenden Beispiel wird eine Liste von Listen mit Strings erstellt, dann die Ausgabedatei zum Schreiben geöffnet und dann in einer for-Schleife die Methode writer.writerow() aufgerufen um die jeweilige Teil-Liste CSV-formatiert in die Datei zu schreiben.Der Inhalt der Datei spam.csv ist danach:Zeile 1 Spalte A;Zeile 1 Spalte B;Zeile 1 Spalte CZeile 2 Spalte A;Zeile 2 Spalte B;Zeile 2 Spalte CZeile 3 Spalte A;;Zeile 3 Spalte CNun kann diese Datei in Excel importiert werden:Abbildung 151 Import in Excel Schritt 1Abbildung 152 - Import in Excel Schritt 2Im nächsten Schritt wählen Sie «Mit Trennzeichen versehen»:Abbildung 153 Import in Excel Schritt 3Als Trennzeichen wählen Sie «Semikolon»:Abbildung 154 Import in Excel Schritt 4Wählen Sie «Fertig stellen». Das Endergebnis sieht in Excel so aus:Abbildung 155 Import In Excel Endergebnis15.9 Daten im JSON-FormatDie JavaScript Object Notation, kurz JSON ist ein textbasiertes Datenformat, das für den Datenaustausch zwischen Anwendungen benutzt wird. Obwohl es ursprünglich für JavaScript entwickelt wurde, wird es inzwischen in beliebigen Programmiersprachen benutzt. Das folgende Beispiel zeigt den Inhalt der Datei MontyPython.json. Sie enthält Informationen zu Mitgliedern der berühmten Comedy-Gruppe im JSON-Format{ "Pythons": [     {"name":"John Cleese", "prof":"Actor", "born":1939, "founder":true },    {"name":"Eric Idle","prof":"Actor", "born":1943, "founder":true },    {"name":"Terry Gilliam","prof":"Actor","born":1940,"founder":true } ] }Diese Struktur sieht ähnlich aus wie ein Dictionary mit einem Schlüssel und einer Liste von drei Dictionaries. Es gibt aber einige Unterschiede, so muss in JSON immer das doppelte Anführungszeichen verwendet werden und der bool-Wert true wird kleingeschrieben.Sie können JSON-Datenstrukturen in Python-Datenstrukturen umwandeln. Importieren Sie das Modul json aus der Standardbibliothek und benutzen Sie die Funktion json.load(Dateiinhalt), um aus dem Dateiinhalt ein Python-Directory zu erzeugen:Die Ausgabe des Programms ist:$ python json_load.py{'Pythons': [{'born': 1939,              'founder': True,              'name': 'John Cleese',              'prof': 'Actor'},             {'born': 1943,              'founder': True,              'name': 'Eric Idle',              'prof': 'Actor'},             {'born': 1940,              'founder': True,              'name': 'Terry Gilliam',              'prof': 'Actor'}]}Eric Idle1943Mit json.dump(String, Dateiobjekt) können Sie auch Daten Ihrer eigenen Python-Programme in eine Datei im JSON-Format schreiben und so für andere Applikationen bereitstellen, die dieses Format lesen können. Das folgende Programm demonstriert dies anhand des students-Dictionary aus Kapitel 14:Die Datei students.json enthält nach der Programmausführung  eine lange Zeile im JSON-Format:{"1001": {"Studiengang": "Chemie", "Name": "Sommer", "Noten": {"Anorganik": 4, "Organik": 5, "Physik": 3}, "Vorname": "Susi"}, "1002": {"Studiengang": "Jura", "Name": "Winter", "Noten": {"BWL": 5, "Buchhaltung": 3, "Statistik": 3, "VWL": 4}, "Vorname": "Walter"}, "1078": {" Studiengang ": "Informatik", "Name": "Sommer", "Vorname": "Susi"}}15.10 Beliebige Objekte haltbar machenIhre Daten können Sie mit den bisher gelernten Techniken als Text, CSV oder JSON abspeichern und später wieder lesen. Für einfach strukturierte Daten ist eventuell das Text- oder CSV-Format ausreichend. Für komplexe Strukturen ist eventuell die Speicherung im JSON-Format eine Alternative. Es wird aber generell empfohlen, die sogenannte Objekt-Serialisierung mit pickle durchzuführen.Das Modul pickle erlaubt es, beliebige Objekte in einem Binärformat abzuspeichern. «to pickle» heisst auf Deutsch soviel wie «pökeln» oder «einlegen», also etwa wie das, was man mit Cornichons macht.  Mit pickle.dump(Objekt, Dateiobjekt) wird eine «Konserve» des Objekts in einer Datei erzeugt. Das folgende Programm demonstriert dies mit der students-Datenstruktur aus Kapitel 14:Beachten Sie den Modus ‘wb’ bei open(). Das beutet, die Datei wird zum Schreiben von Binärdaten geöffnet (Binärdateien haben keine Zeilenstruktur wie die anderen Dateien, die sie bisher kennengelernt haben). Das «konservierte» students-Objekt kann später mit pickle.load(Dateiobjekt) wieder geladen werden:Die Ausgabe von picle_load.py zeigt, dass das students-Objekt aus der Datei komplett wiederhergestellt wurde:{1001: {'Name': 'Sommer',        'Noten': {'Anorganik': 4, 'Organik': 5, 'Physik': 3},        'Studiengang': 'Chemie',        'Vorname': 'Susi'}, 1002: {'Name': 'Winter',        'Noten': {'BWL': 5, 'Buchhaltung': 3, 'Statistik': 3, 'VWL': 4},        'Studiengang': 'Jura',        'Vorname': 'Walter'}, 1078: {' Studiengang ': 'Informatik', 'Name': 'Sommer', 'Vorname': 'Susi'}}Das letzte Beispiel zeigt das Laden, Verändern und das erneute Abspeichern des modifizierten Objekts:Nachdem das Programm pickle_mod.py ausgeführt wurde, wird erneut pickle_load.py gestartet, um zu zeigen, das die Veränderungen am students-Objekt erfolgreich gespeichert wurden:$ python pickle_mod.py$ python pickle_load.py{1001: {'Name': 'Sommer',        'Noten': {'Anorganik': 4, 'Organik': 5, 'Physik': 3},        'Studiengang': 'Chemie',        'Vorname': 'Susi'}, 1002: {'Name': 'Winter',        'Noten': {'BWL': 5, 'Buchhaltung': 3, 'Statistik': 3, 'VWL': 4},        'Studiengang': 'Jura',        'Vorname': 'Walter'}, 1078: {' Studiengang ': 'Informatik',        'Name': 'Sommer',        'Noten': {'Datenbanken': 4, 'Mathematik': 3, 'Python': 4},        'Vorname': 'Susanne'}}15.11 Die Funktion close() und withDie with-Anweisung ist eine relativ neue Erweiterung in Python. In älteren Programmen, die vor der Einführung von with geschrieben wurden wird mit Dateien daher etwas anders umgegangen. Betrachten Sie das folgende Beispiel:Es geht also auch ohne with. Die Dateien werden mit open() geöffnet und mit dateiobjekt.close() wieder geschlossen. Wenn Sie das Schliessen der Datei vergessen, der Aufruf von dateiobjekt.close() aufgrund der Programmstruktur in bestimmten Fällen nicht erreicht wird oder das Programm mit einer Exception abbricht, bevor dateiobjekt.close() ausgeführt werden kann, können beschädigte Dateien zurückbleiben.Die Verwendung von with nimmt Ihnen das Schliessen von Dateien ab. Die Dateien, die innerhalb einer with-Anweisung geöffnet wurden, werden nach Verlassen der with-Suite oder nach dem Auftreten einer Exception automatisch geschlossen. Das heisst: Sie sollten Dateien immer in der neueren Schreibweise mit with öffnen. 15.12 ZusammenfassungMit diesem Kapitel haben Sie verschiedene Möglichkeiten kennengelernt, wie Sie Daten in Ihre Programme einlesen können und die Daten Ihrer Programme dauerhaft speichern können. Dabei helfen folgende eingebaute Funktionen und Anweisungen in Python:• Mit open() können Sie Textdateien und Binärdateien öffnen und erhalten bei Erfolg ein Dateiobjekt zurück.• Mithilfe von Methoden dieses Dateiobjekts können Sie Daten aus einer Datei lesen ( dateiobjekt.read(), dateiobjekt.readlines() ), in eine Datei schreiben ( dateiobjekt.write(), dateiobjekt.writelines() ) oder beides tun. Die Zeilen von Textdateien können Sie auch einfach mit einer for-Schleife über die Elemente des Dateiobjekts lesen.• Dateien, die mit open() geöffnet wurden, sollten immer mit close() wieder geschlossen werden. Dabei hilft die with-Anweisung, die diese Arbeit für Sie automatisch erledigt, wenn open() innerhalb der with-Anweisung aufgerufen wird.• Beim Arbeiten mit Dateien können Ausnahmen auftreten, die in Ihren Programmen behandelt werden sollten.Sie haben einige weitere Module aus der Standardbibliothek kennengelernt:• Das Modul csy liefert praktische Funktionen zum Lesen und Schreiben von Dateien im CSV-Format, das von vielen Programmen erzeugt und gelesen werden kann. Damit ist beispielsweise der Datenaustausch mit Microsoft Excel leicht möglich.• Ein Datenaustausch zwischen Programmen wird oft mit JSON-Format angeboten. Das Modul json liefert praktische Funktionen um JSON-Datenstrukturen in Python-Datenstrukturen umzuwandeln und umgekehrt.• Das Modul pickle ermöglicht es Ihnen, Den Zustand beliebiger Objekte in Binärdateien abzuspeichern und diesen Zustand bei einem späteren Programmstart wiederherzustellen.15.13 AufgabenFür alle Aufgaben in diesem Kapitel gilt: Fangen Sie die möglichen Probleme beim Öffnen von Dateien mit try: und except: ab.Für die nächsten Aufgaben benötigen Sie zum Testen eine etwas längere Textdatei. Sie können dafür natürlich eine Datei im Editor anlegen, aber es geht auch einfacher. A) Sie können im Projekt Gutenberg eine grosse Anzahl von Texten frei herunterladen oder B) Sie nehmen eine beliebige Word-Datei und speichern sie Als «Nur Text (.txt) ab.1) Erzeugen Sie ein Programm num_lines.py, das die Namen einer Eingabedatei und einer Ausgabedatei abfragt. Wenn die Eingabedatei existiert, soll das Programm den Inhalt der Eingabedatei mit Zeilennummern versehen und in die Ausgabedatei schreiben. Die Zeilennummern sollen vierstellig und rechtbündig sein. Eventuell müssen Sie sich dafür noch einmal die String-Formatierungen in Kapitel 11.5 ansehen. Ein Beispiel:$ python num_lines.pyEingabedatei: panther.txtAusgabedatei: out.txtDer Inhalt der Datei out.txt nach der Ausführung ist:   1 Der Panther (von Robert Gernhard)   2 Der Panther, der Panther   3 Erst lag er, dann stand er   4 worauf er so erschrak,   5 dass er gleich wieder lag2) Erstellen Sie ein Programm wordcount.py, dass die Anzahl Wörter in einer Textdatei zählt und ausgibt. Vermeiden Sie dabei, dass Satzzeichen und spezielle Zeichen wie %, +, -, *, (, ) usw. nicht mitgezählt werden.3) Erstellen Sie ein Programm wort_suche.py, das eine solche Datei liest und ein Wort, das Sie eingegeben haben sucht. Für jeden Treffer geben Sie die Nummer der Zeile und die Zeile aus, in der das Wort vorkommt.4) Schreiben Sie ein Programm wort_statistik.py, das alle Wörter in einer Textdatei findet und in einer geeigneten Datenstruktur speichert. Jedes Vorkommen eines Wortes wird gezählt. Am Ende soll das Programm die gefundenen Wörter und die Häufigkeit ihres Vorkommens in der Datei ausgeben. Vermeiden Sie dabei, dass Satzzeichen und spezielle Zeichen wie %, +, -, *, (, ) usw. nicht mitgezählt werden.5) 16 Mehr zu FunktionenIn den Kapiteln 5 und 13 haben Sie die Grundlagen von Funktionen und Modulen sowie den Import-Mechanismus von Python kennengelernt. Sie können bereits eigene Funktionen und Module erstellen. Funktionen bieten aber noch weitere Möglichkeiten, die Sie in diesem Kapitel kennenlernen werden.16.1 LernzieleNach der Bearbeitung dieses Kapitels können Sie:• Mit help() Beschreibungen Ihrer eigenen Funktionen anzeigen• Schlüsselwortparameter benutzen• Standardwerte für Parameter setzen• Funktionen mit beliebig vielen Parametern schreiben• Python-Programmen Argumente auf der Kommandozeile übergeben16.2 Der DocstringDie erste Anweisung des Funktionskörpers kann auch ein String-Literal sein. Das ist dann der sogenannter Dokumentationsstring der Funktion, auch Docstring genannt. (Mehr zu Docstrings kann im Abschnitt Dokumentationsstrings nachgelesen werden). Es gibt Werkzeuge, die Docstrings verwenden, um automatisch Online-Dokumentation oder gedruckte Dokumentation zu erzeugen oder es dem Anwender ermöglichen, interaktiv den Code zu durchsuchen. Die Verwendung von Docstrings ist eine gute Konvention, an die man sich bei der Programmierung nach Möglichkeit halten sollte.Klassen und ObjekteMehr zu Klassen3